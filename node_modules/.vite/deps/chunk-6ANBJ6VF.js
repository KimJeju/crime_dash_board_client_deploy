import {
  animated,
  appearance_default,
  ascending_default,
  band,
  color,
  date_default,
  descending_default,
  diverging_default,
  expand_default,
  globals_exports,
  insideOut_default,
  linear,
  log,
  none_default,
  none_default2,
  number_default,
  ordinal,
  pie_default,
  point,
  pow,
  reverse_default,
  sequential,
  silhouette_default,
  sqrt,
  stack_default,
  threshold,
  time,
  useIsomorphicLayoutEffect,
  useTransition,
  utcTime,
  wiggle_default
} from "./chunk-GLJCUH22.js";
import {
  NoSsr,
  Popper
} from "./chunk-PNURAIDV.js";
import {
  Typography_default
} from "./chunk-YDUXECEX.js";
import {
  useSlotProps
} from "./chunk-NMXVP3SY.js";
import {
  useThemeProps
} from "./chunk-V2PSWLIE.js";
import {
  useTheme
} from "./chunk-5FPMLQ6X.js";
import {
  shouldForwardProp
} from "./chunk-Q2TVENW2.js";
import {
  init_ownerWindow,
  init_useControlled,
  init_useEnhancedEffect,
  init_useForkRef,
  init_useId,
  init_utils,
  ownerWindow,
  useControlled,
  useEnhancedEffect_default,
  useForkRef,
  useId
} from "./chunk-CROZOF2W.js";
import {
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_clsx,
  init_composeClasses,
  init_generateUtilityClass,
  init_generateUtilityClasses,
  styled_default
} from "./chunk-LZFWWSXL.js";
import {
  _extends,
  init_extends
} from "./chunk-TRLI7EVB.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-IGUZOEEO.js";
import {
  require_prop_types
} from "./chunk-7TYQWO6A.js";
import {
  require_jsx_runtime
} from "./chunk-NRBATONI.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
init_extends();
var React57 = __toESM(require_react());
var import_prop_types23 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
init_objectWithoutPropertiesLoose();
init_extends();
var React24 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/context/CartesianProvider/computeValue.js
init_extends();

// node_modules/@mui/x-charts/esm/constants.js
var DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
var DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
var DEFAULT_MARGINS = {
  top: 50,
  bottom: 50,
  left: 50,
  right: 50
};

// node_modules/@mui/x-charts/esm/models/axis.js
function isBandScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "band";
}
function isPointScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "point";
}

// node_modules/@mui/x-charts/esm/internals/colorScale.js
function getSequentialColorScale(config) {
  if (config.type === "piecewise") {
    return threshold(config.thresholds, config.colors);
  }
  return sequential([config.min ?? 0, config.max ?? 100], config.color);
}
function getOrdinalColorScale(config) {
  if (config.values) {
    return ordinal(config.values, config.colors).unknown(config.unknownColor ?? null);
  }
  return ordinal(config.colors.map((_, index) => index), config.colors).unknown(config.unknownColor ?? null);
}
function getColorScale(config) {
  return config.type === "ordinal" ? getOrdinalColorScale(config) : getSequentialColorScale(config);
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var React = __toESM(require_react());

// node_modules/@mui/x-charts/esm/internals/isBandScale.js
function isBandScale(scale) {
  return scale.bandwidth !== void 0;
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
function getTickNumber(params) {
  const {
    tickMaxStep,
    tickMinStep,
    tickNumber,
    range,
    domain
  } = params;
  const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
  const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
  const defaultizedTickNumber = tickNumber ?? Math.floor(Math.abs(range[1] - range[0]) / 50);
  return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
}
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function useTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement = "middle"
  } = options;
  return React.useMemo(() => {
    if (isBandScale(scale)) {
      const domain = scale.domain();
      if (scale.bandwidth() > 0) {
        const filteredDomain2 = typeof tickInterval === "function" && domain.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain;
        return [...filteredDomain2.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick"
          })) ?? `${value}`,
          offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
          labelOffset: tickLabelPlacement === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement] - offsetRatio[tickPlacement])
        })), ...tickPlacement === "extremities" ? [{
          formattedValue: void 0,
          offset: scale.range()[1],
          labelOffset: 0
        }] : []];
      }
      const filteredDomain = typeof tickInterval === "function" && domain.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain;
      return filteredDomain.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick"
        })) ?? `${value}`,
        offset: scale(value),
        labelOffset: 0
      }));
    }
    if (scale.domain().length === 0 || scale.domain()[0] === scale.domain()[1]) {
      return [];
    }
    const ticks = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
    return ticks.map((value) => ({
      value,
      formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
        location: "tick"
      })) ?? scale.tickFormat(tickNumber)(value),
      offset: scale(value),
      labelOffset: 0
    }));
  }, [scale, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacement]);
}

// node_modules/@mui/x-charts/esm/internals/getScale.js
function getScale(scaleType, domain, range) {
  switch (scaleType) {
    case "log":
      return log(domain, range);
    case "pow":
      return pow(domain, range);
    case "sqrt":
      return sqrt(domain, range);
    case "time":
      return time(domain, range);
    case "utc":
      return utcTime(domain, range);
    default:
      return linear(domain, range);
  }
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/getAxisExtremum.js
var axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis, formattedSeries) => {
  var _a;
  const getter = getters[chartType];
  const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
  const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
    series,
    axis,
    isDefaultAxis
  })) ?? [null, null];
  const [minData, maxData] = acc;
  if (minData === null || maxData === null) {
    return [minChartTypeData, maxChartTypeData];
  }
  if (minChartTypeData === null || maxChartTypeData === null) {
    return [minData, maxData];
  }
  return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
};
var getAxisExtremum = (axis, getters, isDefaultAxis, formattedSeries) => {
  const charTypes = Object.keys(getters);
  return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis, formattedSeries), [null, null]);
};

// node_modules/@mui/x-charts/esm/context/CartesianProvider/computeValue.js
var getRange = (drawingArea, axisName, isReverse) => {
  const range = axisName === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
  return isReverse ? range.reverse() : range;
};
var zoomedScaleRange = (scaleRange, zoomRange) => {
  const rangeGap = scaleRange[1] - scaleRange[0];
  const zoomGap = zoomRange[1] - zoomRange[0];
  const min = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
  const max = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
  return [min, max];
};
var isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
function createDateFormatter(axis, range) {
  const timeScale = time(axis.data, range);
  return (v, {
    location
  }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v) : `${v.toLocaleString()}`;
}
var DEFAULT_CATEGORY_GAP_RATIO = 0.2;
var DEFAULT_BAR_GAP_RATIO = 0.1;
function computeValue(drawingArea, formattedSeries, inAxis, extremumGetters, axisName, zoomRange = [0, 100]) {
  const DEFAULT_AXIS_KEY = axisName === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  const allAxis = [...(inAxis == null ? void 0 : inAxis.map((axis, index) => _extends({
    id: `defaultized-${axisName}-axis-${index}`
  }, axis))) ?? [], ...inAxis === void 0 || inAxis.findIndex(({
    id
  }) => id === DEFAULT_AXIS_KEY) === -1 ? [{
    id: DEFAULT_AXIS_KEY,
    scaleType: "linear"
  }] : []];
  const completeAxis = {};
  allAxis.forEach((axis, axisIndex) => {
    const isDefaultAxis = axisIndex === 0;
    const [minData, maxData] = getAxisExtremum(axis, extremumGetters, isDefaultAxis, formattedSeries);
    const range = getRange(drawingArea, axisName, axis.reverse);
    if (isBandScaleConfig(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
      const scaleRange = axisName === "x" ? range : [range[1], range[0]];
      const zoomedRange2 = zoomedScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({
        categoryGapRatio,
        barGapRatio
      }, axis, {
        scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (isPointScaleConfig(axis)) {
      const scaleRange = axisName === "x" ? range : [...range].reverse();
      const zoomedRange2 = zoomedScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({}, axis, {
        scale: point(axis.data, zoomedRange2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === "band" || axis.scaleType === "point") {
      return;
    }
    const scaleType = axis.scaleType ?? "linear";
    const extremums = [axis.min ?? minData, axis.max ?? maxData];
    const rawTickNumber = getTickNumber(_extends({}, axis, {
      range,
      domain: extremums
    }));
    const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
    const zoomedRange = zoomedScaleRange(range, zoomRange);
    const scale = getScale(scaleType, extremums, zoomedRange).nice(rawTickNumber);
    const [minDomain, maxDomain] = scale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = _extends({}, axis, {
      scaleType,
      scale: scale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && getColorScale(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/normalizeAxis.js
init_extends();
var normalizeAxis = (axis, dataset, axisName) => {
  return axis == null ? void 0 : axis.map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw Error(`MUI X Charts: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  });
};

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianProvider.js
var React8 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/hooks/useDrawingArea.js
var React4 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/DrawingProvider.js
init_extends();
var React3 = __toESM(require_react());
init_useId();

// node_modules/@mui/x-charts/esm/hooks/useChartDimensions.js
init_extends();
var React2 = __toESM(require_react());
var useChartDimensions = (width, height, margin) => {
  const defaultizedMargin = _extends({}, DEFAULT_MARGINS, margin);
  const drawingArea = React2.useMemo(() => ({
    left: defaultizedMargin.left,
    top: defaultizedMargin.top,
    right: defaultizedMargin.right,
    bottom: defaultizedMargin.bottom,
    width: Math.max(0, width - defaultizedMargin.left - defaultizedMargin.right),
    height: Math.max(0, height - defaultizedMargin.top - defaultizedMargin.bottom)
  }), [width, height, defaultizedMargin.top, defaultizedMargin.bottom, defaultizedMargin.left, defaultizedMargin.right]);
  return drawingArea;
};
var useChartDimensions_default = useChartDimensions;

// node_modules/@mui/x-charts/esm/context/DrawingProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var DrawingContext = React3.createContext({
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 300,
  width: 400,
  chartId: ""
});
if (true) {
  DrawingContext.displayName = "DrawingContext";
}
var SvgContext = React3.createContext({
  isInitialized: false,
  data: {
    current: null
  }
});
if (true) {
  SvgContext.displayName = "SvgContext";
}
function DrawingProvider(props) {
  const {
    width,
    height,
    margin,
    svgRef,
    children
  } = props;
  const drawingArea = useChartDimensions_default(width, height, margin);
  const chartId = useId();
  const value = React3.useMemo(() => _extends({
    chartId: chartId ?? ""
  }, drawingArea), [chartId, drawingArea]);
  const refValue = React3.useMemo(() => ({
    isInitialized: true,
    data: svgRef
  }), [svgRef]);
  return (0, import_jsx_runtime.jsx)(SvgContext.Provider, {
    value: refValue,
    children: (0, import_jsx_runtime.jsx)(DrawingContext.Provider, {
      value,
      children
    })
  });
}

// node_modules/@mui/x-charts/esm/hooks/useDrawingArea.js
function useDrawingArea() {
  const {
    left,
    top,
    width,
    height,
    bottom,
    right
  } = React4.useContext(DrawingContext);
  return React4.useMemo(() => ({
    left,
    top,
    width,
    height,
    bottom,
    right
  }), [height, left, top, width, bottom, right]);
}

// node_modules/@mui/x-charts/esm/hooks/useSeries.js
var React6 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/SeriesContextProvider.js
init_extends();
var React5 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/internals/defaultizeColor.js
init_extends();
var DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
function defaultizeColor(series, seriesIndex, colors = DEFAULT_COLORS) {
  if (series.type === "pie") {
    return _extends({}, series, {
      data: series.data.map((d, index) => _extends({
        color: colors[index % colors.length]
      }, d))
    });
  }
  return _extends({
    color: colors[seriesIndex % colors.length]
  }, series);
}

// node_modules/@mui/x-charts/esm/colorPalettes/colorPalettes.js
var blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
var blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
var blueberryTwilightPalette = (mode) => mode === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;
var mangoFusionPaletteLight = ["#173A5E", "#00A3A0", "#C91B63", "#EF5350", "#FFA726", "#B800D8", "#60009B", "#2E96FF", "#2731C8", "#03008D"];
var mangoFusionPaletteDark = ["#41698F", "#19D0CD", "#DE196B", "#FC5F5C", "#FFD771", "#DA00FF", "#9001CB", "#72CCFF", "#2E96FF", "#3B48E0"];
var mangoFusionPalette = (mode) => mode === "dark" ? mangoFusionPaletteDark : mangoFusionPaletteLight;
var cheerfulFiestaPaletteDark = ["#0059B2", "#2E96FF", "#FFC24C", "#FF9F0E", "#F38200", "#2ABFDE", "#1F94AD", "#BD2C38", "#FF3143", "#FF8282"];
var cheerfulFiestaPaletteLight = ["#003A75", "#007FFF", "#FFC24C", "#FF9D09", "#CA6C00", "#127D94", "#1F94AD", "#C82634", "#FF3143", "#FF7E7E"];
var cheerfulFiestaPalette = (mode) => mode === "dark" ? cheerfulFiestaPaletteDark : cheerfulFiestaPaletteLight;

// node_modules/@mui/x-charts/esm/context/SeriesContextProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var SeriesContext = React5.createContext({
  isInitialized: false,
  data: {}
});
if (true) {
  SeriesContext.displayName = "SeriesContext";
}
var preprocessSeries = (series, colors, seriesFormatters, dataset) => {
  const seriesGroups = {};
  series.forEach((seriesData, seriesIndex) => {
    var _a;
    const {
      id = `auto-generated-id-${seriesIndex}`,
      type
    } = seriesData;
    if (seriesGroups[type] === void 0) {
      seriesGroups[type] = {
        series: {},
        seriesOrder: []
      };
    }
    if (((_a = seriesGroups[type]) == null ? void 0 : _a.series[id]) !== void 0) {
      throw new Error(`MUI X Charts: series' id "${id}" is not unique.`);
    }
    seriesGroups[type].series[id] = _extends({
      id
    }, defaultizeColor(seriesData, seriesIndex, colors));
    seriesGroups[type].seriesOrder.push(id);
  });
  const formattedSeries = {};
  Object.keys(seriesFormatters).forEach((type) => {
    var _a;
    const group = seriesGroups[type];
    if (group !== void 0) {
      formattedSeries[type] = ((_a = seriesFormatters[type]) == null ? void 0 : _a.call(seriesFormatters, group, dataset)) ?? seriesGroups[type];
    }
  });
  return formattedSeries;
};
function SeriesContextProvider(props) {
  const {
    series,
    dataset,
    colors = blueberryTwilightPalette,
    seriesFormatters,
    children
  } = props;
  const theme = useTheme();
  const formattedSeries = React5.useMemo(() => ({
    isInitialized: true,
    data: preprocessSeries(series, typeof colors === "function" ? colors(theme.palette.mode) : colors, seriesFormatters, dataset)
  }), [series, colors, theme.palette.mode, seriesFormatters, dataset]);
  return (0, import_jsx_runtime2.jsx)(SeriesContext.Provider, {
    value: formattedSeries,
    children
  });
}

// node_modules/@mui/x-charts/esm/hooks/useSeries.js
function useSeries() {
  const {
    isInitialized,
    data
  } = React6.useContext(SeriesContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the series ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}
function usePieSeries() {
  const series = useSeries();
  return React6.useMemo(() => series.pie, [series.pie]);
}
function useLineSeries() {
  const series = useSeries();
  return React6.useMemo(() => series.line, [series.line]);
}
function useBarSeries() {
  const series = useSeries();
  return React6.useMemo(() => series.bar, [series.bar]);
}
function useScatterSeries() {
  const series = useSeries();
  return React6.useMemo(() => series.scatter, [series.scatter]);
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianContext.js
var React7 = __toESM(require_react());
var CartesianContext = React7.createContext({
  isInitialized: false,
  data: {
    xAxis: {},
    yAxis: {},
    xAxisIds: [],
    yAxisIds: []
  }
});
if (true) {
  CartesianContext.displayName = "CartesianContext";
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianProvider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function CartesianContextProvider(props) {
  const {
    xAxis: inXAxis,
    yAxis: inYAxis,
    dataset,
    xExtremumGetters,
    yExtremumGetters,
    children
  } = props;
  const formattedSeries = useSeries();
  const drawingArea = useDrawingArea();
  const xAxis = React8.useMemo(() => normalizeAxis(inXAxis, dataset, "x"), [inXAxis, dataset]);
  const yAxis = React8.useMemo(() => normalizeAxis(inYAxis, dataset, "y"), [inYAxis, dataset]);
  const xValues = React8.useMemo(() => computeValue(drawingArea, formattedSeries, xAxis, xExtremumGetters, "x"), [drawingArea, formattedSeries, xAxis, xExtremumGetters]);
  const yValues = React8.useMemo(() => computeValue(drawingArea, formattedSeries, yAxis, yExtremumGetters, "y"), [drawingArea, formattedSeries, yAxis, yExtremumGetters]);
  const value = React8.useMemo(() => ({
    isInitialized: true,
    data: {
      xAxis: xValues.axis,
      yAxis: yValues.axis,
      xAxisIds: xValues.axisIds,
      yAxisIds: yValues.axisIds
    }
  }), [xValues, yValues]);
  return (0, import_jsx_runtime3.jsx)(CartesianContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/useCartesianContext.js
var React9 = __toESM(require_react());
var useCartesianContext = () => {
  const {
    data
  } = React9.useContext(CartesianContext);
  return data;
};

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
init_extends();
init_objectWithoutPropertiesLoose();
var React16 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_composeClasses();
init_generateUtilityClass();
init_generateUtilityClasses();

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var React15 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/InteractionProvider.js
init_extends();
var React10 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var InteractionContext = React10.createContext({
  item: null,
  axis: {
    x: null,
    y: null
  },
  useVoronoiInteraction: false,
  dispatch: () => null
});
if (true) {
  InteractionContext.displayName = "InteractionContext";
}
var dataReducer = (prevState, action) => {
  switch (action.type) {
    case "enterItem":
      return _extends({}, prevState, {
        item: action.data
      });
    case "exitChart":
      if (prevState.item === null && prevState.axis.x === null && prevState.axis.y === null) {
        return prevState;
      }
      return _extends({}, prevState, {
        axis: {
          x: null,
          y: null
        },
        item: null
      });
    case "updateVoronoiUsage":
      return _extends({}, prevState, {
        useVoronoiInteraction: action.useVoronoiInteraction
      });
    case "leaveItem":
      if (prevState.item === null || Object.keys(action.data).some((key) => action.data[key] !== prevState.item[key])) {
        return prevState;
      }
      return _extends({}, prevState, {
        item: null
      });
    case "updateAxis":
      if (action.data.x === prevState.axis.x && action.data.y === prevState.axis.y) {
        return prevState;
      }
      return _extends({}, prevState, {
        axis: action.data
      });
    default:
      return prevState;
  }
};
function InteractionProvider(props) {
  const {
    children
  } = props;
  const [data, dispatch] = React10.useReducer(dataReducer, {
    item: null,
    axis: {
      x: null,
      y: null
    },
    useVoronoiInteraction: false
  });
  const value = React10.useMemo(() => _extends({}, data, {
    dispatch
  }), [data]);
  return (0, import_jsx_runtime4.jsx)(InteractionContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/HighlightedProvider.js
init_extends();
init_objectWithoutPropertiesLoose();
var React12 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_useControlled();

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/HighlightedContext.js
var React11 = __toESM(require_react());
var HighlightedContext = React11.createContext({
  isInitialized: false,
  data: {
    highlightedItem: null,
    setHighlighted: () => {
    },
    clearHighlighted: () => {
    },
    isHighlighted: () => false,
    isFaded: () => false
  }
});
if (true) {
  HighlightedContext.displayName = "HighlightedContext";
}

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/createIsFaded.js
var createIsFaded = (highlightScope, highlightedItem) => (input) => {
  if (!highlightScope) {
    return false;
  }
  if (highlightScope.fade === "series") {
    return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId) && input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
  }
  if (highlightScope.fade === "global") {
    return input.seriesId !== (highlightedItem == null ? void 0 : highlightedItem.seriesId) || input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
  }
  return false;
};

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/createIsHighlighted.js
var createIsHighlighted = (highlightScope, highlightedItem) => (input) => {
  if (!highlightScope) {
    return false;
  }
  if (highlightScope.highlight === "series") {
    return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
  }
  if (highlightScope.highlight === "item") {
    return input.dataIndex === (highlightedItem == null ? void 0 : highlightedItem.dataIndex) && input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
  }
  return false;
};

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/HighlightedProvider.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var _excluded = ["highlighted", "faded"];
var mergeDeprecatedOptions = (options) => {
  const _ref = options ?? {}, {
    highlighted,
    faded
  } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
  return _extends({
    highlight: highlighted,
    fade: faded
  }, rest);
};
function HighlightedProvider({
  children,
  highlightedItem: highlightedItemProps,
  onHighlightChange
}) {
  const [highlightedItem, setHighlightedItem] = useControlled({
    controlled: highlightedItemProps,
    default: null,
    name: "HighlightedProvider",
    state: "highlightedItem"
  });
  const series = useSeries();
  const seriesById = React12.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    Object.keys(series).forEach((seriesType) => {
      const seriesData = series[seriesType];
      Object.keys((seriesData == null ? void 0 : seriesData.series) ?? {}).forEach((seriesId) => {
        const seriesItem = seriesData == null ? void 0 : seriesData.series[seriesId];
        map.set(seriesId, mergeDeprecatedOptions(seriesItem == null ? void 0 : seriesItem.highlightScope));
      });
    });
    return map;
  }, [series]);
  const highlightScope = highlightedItem && highlightedItem.seriesId ? seriesById.get(highlightedItem.seriesId) ?? void 0 : void 0;
  const providerValue = React12.useMemo(() => {
    return {
      isInitialized: true,
      data: {
        highlightScope,
        highlightedItem,
        setHighlighted: (itemData) => {
          setHighlightedItem(itemData);
          onHighlightChange == null ? void 0 : onHighlightChange(itemData);
        },
        clearHighlighted: () => {
          setHighlightedItem(null);
          onHighlightChange == null ? void 0 : onHighlightChange(null);
        },
        isHighlighted: createIsHighlighted(highlightScope, highlightedItem),
        isFaded: createIsFaded(highlightScope, highlightedItem)
      }
    };
  }, [highlightedItem, highlightScope, setHighlightedItem, onHighlightChange]);
  return (0, import_jsx_runtime5.jsx)(HighlightedContext.Provider, {
    value: providerValue,
    children
  });
}
true ? HighlightedProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types.default.node,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types.default.shape({
    dataIndex: import_prop_types.default.number,
    seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types.default.func
} : void 0;

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/useHighlighted.js
var React13 = __toESM(require_react());
function useHighlighted() {
  const {
    isInitialized,
    data
  } = React13.useContext(HighlightedContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the highlighted ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts/esm/context/HighlightedProvider/useItemHighlighted.js
function useItemHighlighted(item) {
  const highlighted = useHighlighted();
  if (!item) {
    return {
      isHighlighted: false,
      isFaded: false
    };
  }
  const isHighlighted = highlighted.isHighlighted(item);
  const isFaded = !isHighlighted && highlighted.isFaded(item);
  return {
    isHighlighted,
    isFaded
  };
}

// node_modules/@mui/x-charts/esm/context/ZAxisContextProvider.js
init_extends();
var React14 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var ZAxisContext = React14.createContext({
  zAxis: {},
  zAxisIds: []
});
if (true) {
  ZAxisContext.displayName = "ZAxisContext";
}
function ZAxisContextProvider(props) {
  const {
    zAxis: inZAxis,
    dataset,
    children
  } = props;
  const zAxis = React14.useMemo(() => inZAxis == null ? void 0 : inZAxis.map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw Error("MUI X Charts: z-axis uses `dataKey` but no `dataset` is provided.");
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  }), [inZAxis, dataset]);
  const value = React14.useMemo(() => {
    const allZAxis = (zAxis == null ? void 0 : zAxis.map((axis, index) => _extends({
      id: `defaultized-z-axis-${index}`
    }, axis))) ?? [];
    const completedZAxis = {};
    allZAxis.forEach((axis) => {
      completedZAxis[axis.id] = _extends({}, axis, {
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" && axis.data ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap.type === "continuous" ? _extends({
          min: axis.min,
          max: axis.max
        }, axis.colorMap) : axis.colorMap))
      });
    });
    return {
      zAxis: completedZAxis,
      zAxisIds: allZAxis.map(({
        id
      }) => id)
    };
  }, [zAxis]);
  return (0, import_jsx_runtime6.jsx)(ZAxisContext.Provider, {
    value,
    children
  });
}
true ? ZAxisContextProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types2.default.node,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types2.default.arrayOf(import_prop_types2.default.object),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types2.default.arrayOf(import_prop_types2.default.shape({
    colorMap: import_prop_types2.default.oneOfType([import_prop_types2.default.shape({
      colors: import_prop_types2.default.arrayOf(import_prop_types2.default.string).isRequired,
      type: import_prop_types2.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types2.default.string,
      values: import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number, import_prop_types2.default.string]).isRequired)
    }), import_prop_types2.default.shape({
      color: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.string.isRequired), import_prop_types2.default.func]).isRequired,
      max: import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number]),
      min: import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number]),
      type: import_prop_types2.default.oneOf(["continuous"]).isRequired
    }), import_prop_types2.default.shape({
      colors: import_prop_types2.default.arrayOf(import_prop_types2.default.string).isRequired,
      thresholds: import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number]).isRequired).isRequired,
      type: import_prop_types2.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types2.default.array,
    dataKey: import_prop_types2.default.string,
    id: import_prop_types2.default.string,
    max: import_prop_types2.default.number,
    min: import_prop_types2.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var useInteractionItemProps = (skip) => {
  const {
    dispatch: dispatchInteraction
  } = React15.useContext(InteractionContext);
  const {
    setHighlighted,
    clearHighlighted
  } = useHighlighted();
  if (skip) {
    return () => ({});
  }
  const getInteractionItemProps = (data) => {
    const onPointerDown = (event) => {
      if (event.currentTarget.hasPointerCapture(event.pointerId)) {
        event.currentTarget.releasePointerCapture(event.pointerId);
      }
    };
    const onPointerEnter = () => {
      dispatchInteraction({
        type: "enterItem",
        data
      });
      setHighlighted({
        seriesId: data.seriesId,
        dataIndex: data.dataIndex
      });
    };
    const onPointerLeave = (event) => {
      event.currentTarget.releasePointerCapture(event.pointerId);
      dispatchInteraction({
        type: "leaveItem",
        data
      });
      clearHighlighted();
    };
    return {
      onPointerEnter,
      onPointerLeave,
      onPointerDown
    };
  };
  return getInteractionItemProps;
};

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded2 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick"];
function getBarElementUtilityClass(slot) {
  return generateUtilityClass("MuiBarElement", slot);
}
var barElementClasses = generateUtilityClasses("MuiBarElement", ["root"]);
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getBarElementUtilityClass, classes);
};
var BarElementPath = styled_default(animated.rect, {
  name: "MuiBarElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  stroke: "none",
  fill: ownerState.isHighlighted ? color(ownerState.color).brighter(0.5).formatHex() : ownerState.color,
  transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
  opacity: ownerState.isFaded && 0.3 || 1
}));
function BarElement(props) {
  const {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    slots,
    slotProps,
    style,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses(ownerState);
  const Bar = (slots == null ? void 0 : slots.bar) ?? BarElementPath;
  const barProps = useSlotProps({
    elementType: Bar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
    externalForwardedProps: other,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "bar",
      seriesId: id,
      dataIndex
    }), {
      style,
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime7.jsx)(Bar, _extends({}, barProps));
}
true ? BarElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types3.default.object,
  dataIndex: import_prop_types3.default.number.isRequired,
  id: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/getColor.js
function getColor(series, xAxis, yAxis) {
  const verticalLayout = series.layout === "vertical";
  const bandColorScale = verticalLayout ? xAxis == null ? void 0 : xAxis.colorScale : yAxis == null ? void 0 : yAxis.colorScale;
  const valueColorScale = verticalLayout ? yAxis == null ? void 0 : yAxis.colorScale : xAxis == null ? void 0 : xAxis.colorScale;
  const bandValues = verticalLayout ? xAxis == null ? void 0 : xAxis.data : yAxis == null ? void 0 : yAxis.data;
  if (valueColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color2 = value === null ? series.color : valueColorScale(value);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  if (bandColorScale && bandValues) {
    return (dataIndex) => {
      const value = bandValues[dataIndex];
      const color2 = value === null ? series.color : bandColorScale(value);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/hooks/useChartId.js
var React17 = __toESM(require_react());
function useChartId() {
  const {
    chartId
  } = React17.useContext(DrawingContext);
  return React17.useMemo(() => chartId, [chartId]);
}

// node_modules/@mui/x-charts/esm/hooks/useAxis.js
function useXAxis(identifier) {
  const {
    xAxis,
    xAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : xAxisIds[identifier ?? 0];
  return xAxis[id];
}
function useYAxis(identifier) {
  const {
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : yAxisIds[identifier ?? 0];
  return yAxis[id];
}

// node_modules/@mui/x-charts/esm/hooks/useScale.js
function getValueToPositionMapper(scale) {
  if (isBandScale(scale)) {
    return (value) => (scale(value) ?? 0) + scale.bandwidth() / 2;
  }
  return (value) => scale(value);
}
function useXScale(identifier) {
  const axis = useXAxis(identifier);
  return axis.scale;
}
function useYScale(identifier) {
  const axis = useYAxis(identifier);
  return axis.scale;
}

// node_modules/@mui/x-charts/esm/hooks/useColorScale.js
var React18 = __toESM(require_react());
function useXColorScale(identifier) {
  const {
    xAxis,
    xAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : xAxisIds[identifier ?? 0];
  return xAxis[id].colorScale;
}
function useYColorScale(identifier) {
  const {
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : yAxisIds[identifier ?? 0];
  return yAxis[id].colorScale;
}
function useZColorScale(identifier) {
  var _a;
  const {
    zAxis,
    zAxisIds
  } = React18.useContext(ZAxisContext);
  const id = typeof identifier === "string" ? identifier : zAxisIds[identifier ?? 0];
  return (_a = zAxis[id]) == null ? void 0 : _a.colorScale;
}

// node_modules/@mui/x-charts/esm/hooks/useSvgRef.js
var React19 = __toESM(require_react());
function useSvgRef() {
  const {
    isInitialized,
    data
  } = React19.useContext(SvgContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js
init_objectWithoutPropertiesLoose();
init_extends();
var React20 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/BarChart/getRadius.js
var getRadius = (corner, {
  hasNegative,
  hasPositive,
  borderRadius,
  layout
}) => {
  if (!borderRadius) {
    return 0;
  }
  const isVertical = layout === "vertical";
  if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
    return borderRadius;
  }
  if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
    return borderRadius;
  }
  return 0;
};

// node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded3 = ["style", "maskId"];
var buildInset = (corners) => `inset(0px round ${corners.topLeft}px ${corners.topRight}px ${corners.bottomRight}px ${corners.bottomLeft}px)`;
function BarClipRect(props) {
  var _a, _b;
  const radiusData = props.ownerState;
  return (0, import_jsx_runtime8.jsx)(animated.rect, {
    style: _extends({}, props.style, {
      clipPath: (props.ownerState.layout === "vertical" ? (_a = props.style) == null ? void 0 : _a.height : (_b = props.style) == null ? void 0 : _b.width).to((value) => buildInset({
        topLeft: Math.min(value, getRadius("top-left", radiusData)),
        topRight: Math.min(value, getRadius("top-right", radiusData)),
        bottomRight: Math.min(value, getRadius("bottom-right", radiusData)),
        bottomLeft: Math.min(value, getRadius("bottom-left", radiusData))
      }))
    })
  });
}
function BarClipPath(props) {
  const {
    style,
    maskId
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded3);
  if (!props.borderRadius || props.borderRadius <= 0) {
    return null;
  }
  return (0, import_jsx_runtime8.jsx)("clipPath", {
    id: maskId,
    children: (0, import_jsx_runtime8.jsx)(BarClipRect, {
      ownerState: rest,
      style
    })
  });
}

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
init_objectWithoutPropertiesLoose();
init_extends();
var React23 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
init_extends();
init_objectWithoutPropertiesLoose();
var React22 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/barLabelClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
init_composeClasses();
function getBarLabelUtilityClass(slot) {
  return generateUtilityClass("MuiBarLabel", slot);
}
var barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded"]);
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getBarLabelUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/getBarLabel.js
var getBarLabel = (options) => {
  const {
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  } = options;
  if (barLabel === "value") {
    return value ? value == null ? void 0 : value.toString() : null;
  }
  return barLabel({
    seriesId,
    dataIndex,
    value
  }, {
    bar: {
      height,
      width
    }
  });
};

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabel.js
init_objectWithoutPropertiesLoose();
init_extends();
var React21 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var _excluded4 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes"];
var BarLabelComponent = styled_default(animated.text, {
  name: "MuiBarLabel",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${barLabelClasses.faded}`]: styles.faded
  }, {
    [`&.${barLabelClasses.highlighted}`]: styles.highlighted
  }, styles.root]
})(({
  theme
}) => {
  var _a, _b, _c, _d;
  return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
    stroke: "none",
    fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    textAnchor: "middle",
    dominantBaseline: "central",
    pointerEvents: "none",
    opacity: 1,
    [`&.${barLabelClasses.faded}`]: {
      opacity: 0.3
    }
  });
});
function BarLabel(props) {
  const themeProps = useThemeProps({
    props,
    name: "MuiBarLabel"
  });
  const otherProps = _objectWithoutPropertiesLoose(themeProps, _excluded4);
  return (0, import_jsx_runtime9.jsx)(BarLabelComponent, _extends({}, otherProps));
}
true ? BarLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types4.default.object,
  dataIndex: import_prop_types4.default.number.isRequired,
  isFaded: import_prop_types4.default.bool.isRequired,
  isHighlighted: import_prop_types4.default.bool.isRequired,
  seriesId: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string]).isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded5 = ["seriesId", "classes", "color", "style", "dataIndex", "barLabel", "slots", "slotProps", "height", "width", "value"];
var _excluded22 = ["ownerState"];
function BarLabelItem(props) {
  const {
    seriesId,
    classes: innerClasses,
    color: color2,
    style,
    dataIndex,
    barLabel,
    slots,
    slotProps,
    height,
    width,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted,
    dataIndex
  };
  const classes = useUtilityClasses2(ownerState);
  const Component = (slots == null ? void 0 : slots.barLabel) ?? BarLabel;
  const _useSlotProps = useSlotProps({
    elementType: Component,
    externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
    additionalProps: _extends({}, other, {
      style,
      className: classes.root
    }),
    ownerState
  }), {
    ownerState: barLabelOwnerState
  } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  if (!barLabel) {
    return null;
  }
  const formattedLabelText = getBarLabel({
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  });
  if (!formattedLabelText) {
    return null;
  }
  return (0, import_jsx_runtime10.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
    children: formattedLabelText
  }));
}
true ? BarLabelItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["value"]), import_prop_types5.default.func]),
  classes: import_prop_types5.default.object,
  color: import_prop_types5.default.string.isRequired,
  dataIndex: import_prop_types5.default.number.isRequired,
  /**
   * The height of the bar.
   */
  height: import_prop_types5.default.number.isRequired,
  seriesId: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The value of the data point.
   */
  value: import_prop_types5.default.number,
  /**
   * The width of the bar.
   */
  width: import_prop_types5.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded6 = ["bars", "skipAnimation"];
var leaveStyle = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x: x + width / 2,
  height: 0,
  width
} : {
  y: y + height / 2,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle = ({
  x,
  width,
  y,
  height
}) => ({
  x: x + width / 2,
  y: y + height / 2,
  height,
  width
});
function BarLabelPlot(props) {
  const {
    bars,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const barLabelTransition = useTransition(bars, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle,
    leave: null,
    enter: enterStyle,
    update: enterStyle,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime11.jsx)(React23.Fragment, {
    children: barLabelTransition((style, {
      seriesId,
      dataIndex,
      color: color2,
      value,
      width,
      height
    }) => (0, import_jsx_runtime11.jsx)(BarLabelItem, _extends({
      seriesId,
      dataIndex,
      value,
      color: color2,
      width,
      height
    }, other, {
      style
    })))
  });
}

// node_modules/@mui/x-charts/esm/BarChart/checkScaleErrors.js
var getAxisMessage = (axisDirection, axisKey) => {
  const axisName = `${axisDirection}-axis`;
  const axisKeyName = `${axisDirection}Axis`;
  const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return axisKey === axisDefaultKey ? `The first \`${axisKeyName}\`` : `The ${axisName} with id "${axisKey}"`;
};
function checkScaleErrors(verticalLayout, seriesId, xAxisKey, xAxis, yAxisKey, yAxis) {
  const xAxisConfig = xAxis[xAxisKey];
  const yAxisConfig = yAxis[yAxisKey];
  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
  const discreteAxisKey = verticalLayout ? xAxisKey : yAxisKey;
  const continuousAxisKey = verticalLayout ? yAxisKey : xAxisKey;
  const discreteAxisDirection = verticalLayout ? "x" : "y";
  const continuousAxisDirection = verticalLayout ? "y" : "x";
  if (!isBandScaleConfig(discreteAxisConfig)) {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisKey)} should be of type "band" to display the bar series of id "${seriesId}".`);
  }
  if (discreteAxisConfig.data === void 0) {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisKey)} should have data property.`);
  }
  if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
    throw new Error(`MUI X Charts: ${getAxisMessage(continuousAxisDirection, continuousAxisKey)} should be a continuous type to display the bar series of id "${seriesId}".`);
  }
}

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded7 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
function getBandSize({
  bandWidth: W,
  numberOfGroups: N,
  gapRatio: r
}) {
  if (r === 0) {
    return {
      barWidth: W / N,
      offset: 0
    };
  }
  const barWidth = W / (N + (N - 1) * r);
  const offset = r * barWidth;
  return {
    barWidth,
    offset
  };
}
var useAggregatedData = () => {
  const seriesData = useBarSeries() ?? {
    series: {},
    stackingGroups: [],
    seriesOrder: []
  };
  const axisData = useCartesianContext();
  const chartId = useChartId();
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const masks = {};
  const data = stackingGroups.flatMap(({
    ids: groupIds
  }, groupIndex) => {
    return groupIds.flatMap((seriesId) => {
      const xAxisKey = series[seriesId].xAxisKey ?? defaultXAxisId;
      const yAxisKey = series[seriesId].yAxisKey ?? defaultYAxisId;
      const xAxisConfig = xAxis[xAxisKey];
      const yAxisConfig = yAxis[yAxisKey];
      const verticalLayout = series[seriesId].layout === "vertical";
      checkScaleErrors(verticalLayout, seriesId, xAxisKey, xAxis, yAxisKey, yAxis);
      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
      const xScale = xAxisConfig.scale;
      const yScale = yAxisConfig.scale;
      const colorGetter = getColor(series[seriesId], xAxis[xAxisKey], yAxis[yAxisKey]);
      const bandWidth = baseScaleConfig.scale.bandwidth();
      const {
        barWidth,
        offset
      } = getBandSize({
        bandWidth,
        numberOfGroups: stackingGroups.length,
        gapRatio: baseScaleConfig.barGapRatio
      });
      const barOffset = groupIndex * (barWidth + offset);
      const {
        stackedData
      } = series[seriesId];
      return stackedData.map((values, dataIndex) => {
        var _a, _b;
        const valueCoordinates = values.map((v) => verticalLayout ? yScale(v) : xScale(v));
        const minValueCoord = Math.round(Math.min(...valueCoordinates));
        const maxValueCoord = Math.round(Math.max(...valueCoordinates));
        const stackId = series[seriesId].stack;
        const result = {
          seriesId,
          dataIndex,
          layout: series[seriesId].layout,
          x: verticalLayout ? xScale((_a = xAxis[xAxisKey].data) == null ? void 0 : _a[dataIndex]) + barOffset : minValueCoord,
          y: verticalLayout ? minValueCoord : yScale((_b = yAxis[yAxisKey].data) == null ? void 0 : _b[dataIndex]) + barOffset,
          xOrigin: xScale(0),
          yOrigin: yScale(0),
          height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
          width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
          color: colorGetter(dataIndex),
          value: series[seriesId].data[dataIndex],
          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
        };
        if (!masks[result.maskId]) {
          masks[result.maskId] = {
            id: result.maskId,
            width: 0,
            height: 0,
            hasNegative: false,
            hasPositive: false,
            layout: result.layout,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            x: 0,
            y: 0
          };
        }
        const mask = masks[result.maskId];
        mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
        mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
        mask.hasNegative = mask.hasNegative || (result.value ?? 0) < 0;
        mask.hasPositive = mask.hasPositive || (result.value ?? 0) > 0;
        return result;
      });
    });
  });
  return {
    completedData: data,
    masksData: Object.values(masks)
  };
};
var leaveStyle2 = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x,
  height: 0,
  width
} : {
  y,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle2 = ({
  x,
  width,
  y,
  height
}) => ({
  y,
  x,
  height,
  width
});
function BarPlot(props) {
  const {
    completedData,
    masksData
  } = useAggregatedData();
  const {
    skipAnimation,
    onItemClick,
    borderRadius,
    barLabel
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const transition = useTransition(completedData, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  const maskTransition = useTransition(masksData, {
    keys: (v) => v.id,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime12.jsxs)(React24.Fragment, {
    children: [maskTransition((style, {
      id,
      hasPositive,
      hasNegative,
      layout
    }) => {
      return (0, import_jsx_runtime12.jsx)(BarClipPath, {
        maskId: id,
        borderRadius,
        hasNegative,
        hasPositive,
        layout,
        style
      });
    }), transition((style, {
      seriesId,
      dataIndex,
      color: color2,
      maskId
    }) => {
      const barElement = (0, import_jsx_runtime12.jsx)(BarElement, _extends({
        id: seriesId,
        dataIndex,
        color: color2
      }, other, {
        onClick: onItemClick && ((event) => {
          onItemClick(event, {
            type: "bar",
            seriesId,
            dataIndex
          });
        }),
        style
      }));
      if (!borderRadius || borderRadius <= 0) {
        return barElement;
      }
      return (0, import_jsx_runtime12.jsx)("g", {
        clipPath: `url(#${maskId})`,
        children: barElement
      });
    }), barLabel && (0, import_jsx_runtime12.jsx)(BarLabelPlot, _extends({
      bars: completedData,
      skipAnimation,
      barLabel
    }, other))]
  });
}
true ? BarPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["value"]), import_prop_types6.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types6.default.number,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types6.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types6.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/ResponsiveChartContainer.js
init_extends();
init_objectWithoutPropertiesLoose();
var React35 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/ChartContainer/ChartContainer.js
var React33 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/context/ColorProvider.js
var React25 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var ColorContext = React25.createContext({});
if (true) {
  ColorContext.displayName = "ColorContext";
}
function ColorProvider(props) {
  const {
    colorProcessors,
    children
  } = props;
  return (0, import_jsx_runtime13.jsx)(ColorContext.Provider, {
    value: colorProcessors,
    children
  });
}

// node_modules/@mui/x-charts/esm/ChartsSurface.js
init_extends();
init_objectWithoutPropertiesLoose();
var import_prop_types7 = __toESM(require_prop_types());
var React27 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/hooks/useAxisEvents.js
var React26 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/internals/getSVGPoint.js
function getSVGPoint(svg, event) {
  const pt = svg.createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}

// node_modules/@mui/x-charts/esm/hooks/useAxisEvents.js
function getAsANumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
var useAxisEvents = (disableAxisListener) => {
  const svgRef = useSvgRef();
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    dispatch
  } = React26.useContext(InteractionContext);
  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];
  const mousePosition = React26.useRef({
    x: -1,
    y: -1
  });
  React26.useEffect(() => {
    const element = svgRef.current;
    if (element === null || disableAxisListener) {
      return () => {
      };
    }
    function getNewAxisState(axisConfig, mouseValue) {
      const {
        scale,
        data: axisData,
        reverse
      } = axisConfig;
      if (!isBandScale(scale)) {
        const value = scale.invert(mouseValue);
        if (axisData === void 0) {
          return {
            value
          };
        }
        const valueAsNumber = getAsANumber(value);
        const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index) => {
          const v = getAsANumber(pointValue);
          if (v > valueAsNumber) {
            if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {
              return true;
            }
          }
          if (v <= valueAsNumber) {
            if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {
              return true;
            }
          }
          return false;
        });
        return {
          value: closestIndex !== void 0 && closestIndex >= 0 ? axisData[closestIndex] : value,
          index: closestIndex
        };
      }
      const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());
      if (dataIndex < 0 || dataIndex >= axisData.length) {
        return null;
      }
      if (reverse) {
        const reverseIndex = axisData.length - 1 - dataIndex;
        return {
          index: reverseIndex,
          value: axisData[reverseIndex]
        };
      }
      return {
        index: dataIndex,
        value: axisData[dataIndex]
      };
    }
    const handleOut = () => {
      mousePosition.current = {
        x: -1,
        y: -1
      };
      dispatch({
        type: "exitChart"
      });
    };
    const handleMove = (event) => {
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      const svgPoint = getSVGPoint(element, target);
      mousePosition.current = {
        x: svgPoint.x,
        y: svgPoint.y
      };
      const outsideX = svgPoint.x < left || svgPoint.x > left + width;
      const outsideY = svgPoint.y < top || svgPoint.y > top + height;
      if (outsideX || outsideY) {
        dispatch({
          type: "exitChart"
        });
        return;
      }
      const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);
      const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);
      dispatch({
        type: "updateAxis",
        data: {
          x: newStateX,
          y: newStateY
        }
      });
    };
    const handleDown = (event) => {
      const target = event.currentTarget;
      if (!target) {
        return;
      }
      if (target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
    };
    element.addEventListener("pointerdown", handleDown);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerout", handleOut);
    element.addEventListener("pointercancel", handleOut);
    element.addEventListener("pointerleave", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleDown);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerout", handleOut);
      element.removeEventListener("pointercancel", handleOut);
      element.removeEventListener("pointerleave", handleOut);
    };
  }, [svgRef, dispatch, left, width, top, height, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener]);
};

// node_modules/@mui/x-charts/esm/ChartsSurface.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _excluded8 = ["children", "width", "height", "viewBox", "disableAxisListener", "className", "title", "desc"];
var ChartChartsSurfaceStyles = styled_default("svg", {
  name: "MuiChartsSurface",
  slot: "Root"
})(() => ({
  // This prevents default touch actions when using the svg on mobile devices.
  // For example, prevent page scroll & zoom.
  touchAction: "none"
}));
var ChartsSurface = React27.forwardRef(function ChartsSurface2(props, ref) {
  const {
    children,
    width,
    height,
    viewBox,
    disableAxisListener = false,
    title,
    desc
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const svgView = _extends({
    width,
    height,
    x: 0,
    y: 0
  }, viewBox);
  useAxisEvents(disableAxisListener);
  return (0, import_jsx_runtime14.jsxs)(ChartChartsSurfaceStyles, _extends({
    width,
    height,
    viewBox: `${svgView.x} ${svgView.y} ${svgView.width} ${svgView.height}`,
    ref
  }, other, {
    children: [(0, import_jsx_runtime14.jsx)("title", {
      children: title
    }), (0, import_jsx_runtime14.jsx)("desc", {
      children: desc
    }), children]
  }));
});
true ? ChartsSurface.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types7.default.node,
  className: import_prop_types7.default.string,
  desc: import_prop_types7.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types7.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types7.default.number.isRequired,
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object]),
  title: import_prop_types7.default.string,
  viewBox: import_prop_types7.default.shape({
    height: import_prop_types7.default.number,
    width: import_prop_types7.default.number,
    x: import_prop_types7.default.number,
    y: import_prop_types7.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types7.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var React30 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsPiecewiseGradient.js
var React28 = __toESM(require_react());
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
function ChartsPiecewiseGradient(props) {
  const {
    isReversed,
    gradientId,
    size,
    direction,
    scale,
    colorMap
  } = props;
  return (0, import_jsx_runtime15.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
    gradientUnits: "userSpaceOnUse",
    children: colorMap.thresholds.map((threshold2, index) => {
      const x = scale(threshold2);
      if (x === void 0) {
        return null;
      }
      const offset = isReversed ? 1 - x / size : x / size;
      return (0, import_jsx_runtime15.jsxs)(React28.Fragment, {
        children: [(0, import_jsx_runtime15.jsx)("stop", {
          offset,
          stopColor: colorMap.colors[index],
          stopOpacity: 1
        }), (0, import_jsx_runtime15.jsx)("stop", {
          offset,
          stopColor: colorMap.colors[index + 1],
          stopOpacity: 1
        })]
      }, threshold2.toString() + index);
    })
  });
}

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsContinuousGradient.js
var React29 = __toESM(require_react());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var PX_PRECISION = 10;
function ChartsContinuousGradient(props) {
  const {
    isReversed,
    gradientId,
    size,
    direction,
    scale,
    colorScale,
    colorMap
  } = props;
  const extremValues = [colorMap.min ?? 0, colorMap.max ?? 100];
  const extremPositions = extremValues.map(scale).filter((p) => p !== void 0);
  if (extremPositions.length !== 2) {
    return null;
  }
  const interpolator = typeof extremValues[0] === "number" ? number_default(extremValues[0], extremValues[1]) : date_default(extremValues[0], extremValues[1]);
  const numberOfPoints = Math.round((Math.max(...extremPositions) - Math.min(...extremPositions)) / PX_PRECISION);
  const keyPrefix = `${extremValues[0]}-${extremValues[1]}-`;
  return (0, import_jsx_runtime16.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
    gradientUnits: "userSpaceOnUse",
    children: Array.from({
      length: numberOfPoints + 1
    }, (_, index) => {
      const value = interpolator(index / numberOfPoints);
      if (value === void 0) {
        return null;
      }
      const x = scale(value);
      if (x === void 0) {
        return null;
      }
      const offset = isReversed ? 1 - x / size : x / size;
      const color2 = colorScale(value);
      if (color2 === null) {
        return null;
      }
      return (0, import_jsx_runtime16.jsx)("stop", {
        offset,
        stopColor: color2,
        stopOpacity: 1
      }, keyPrefix + index);
    })
  });
}

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
function useChartGradient() {
  const {
    chartId
  } = React30.useContext(DrawingContext);
  return React30.useCallback((axisId, direction) => `${chartId}-gradient-${direction}-${axisId}`, [chartId]);
}
function ChartsAxesGradients() {
  const {
    top,
    height,
    bottom,
    left,
    width,
    right
  } = useDrawingArea();
  const svgHeight = top + height + bottom;
  const svgWidth = left + width + right;
  const getGradientId = useChartGradient();
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  return (0, import_jsx_runtime17.jsxs)("defs", {
    children: [yAxisIds.filter((axisId) => yAxis[axisId].colorMap !== void 0).map((axisId) => {
      const gradientId = getGradientId(axisId, "y");
      const {
        colorMap,
        scale,
        colorScale,
        reverse
      } = yAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime17.jsx)(ChartsPiecewiseGradient, {
          isReversed: !reverse,
          scale,
          colorMap,
          size: svgHeight,
          gradientId,
          direction: "y"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime17.jsx)(ChartsContinuousGradient, {
          isReversed: !reverse,
          scale,
          colorScale,
          colorMap,
          size: svgHeight,
          gradientId,
          direction: "y"
        }, gradientId);
      }
      return null;
    }), xAxisIds.filter((axisId) => xAxis[axisId].colorMap !== void 0).map((axisId) => {
      const gradientId = getGradientId(axisId, "x");
      const {
        colorMap,
        scale,
        reverse,
        colorScale
      } = xAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime17.jsx)(ChartsPiecewiseGradient, {
          isReversed: reverse,
          scale,
          colorMap,
          size: svgWidth,
          gradientId,
          direction: "x"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime17.jsx)(ChartsContinuousGradient, {
          isReversed: reverse,
          scale,
          colorScale,
          colorMap,
          size: svgWidth,
          gradientId,
          direction: "x"
        }, gradientId);
      }
      return null;
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartContainer/useChartContainerHooks.js
init_useForkRef();
var React32 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/ChartContainer/usePluginsMerge.js
var React31 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/BarChart/extremums.js
var getBaseExtremum = (params) => {
  const {
    axis
  } = params;
  const minX = Math.min(...axis.data ?? []);
  const maxX = Math.max(...axis.data ?? []);
  return [minX, maxX];
};
var getValueExtremum = (params) => {
  const {
    series,
    axis,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => series[seriesId].yAxisKey === axis.id || isDefaultAxis && series[seriesId].yAxisKey === void 0).reduce((acc, seriesId) => {
    var _a;
    const [seriesMin, seriesMax] = ((_a = series[seriesId].stackedData) == null ? void 0 : _a.reduce((seriesAcc, values) => [Math.min(...values, ...seriesAcc[0] === null ? [] : [seriesAcc[0]]), Math.max(...values, ...seriesAcc[1] === null ? [] : [seriesAcc[1]])], series[seriesId].stackedData[0])) ?? [null, null];
    return [acc[0] === null ? seriesMin : Math.min(seriesMin, acc[0]), acc[1] === null ? seriesMax : Math.max(seriesMax, acc[1])];
  }, [null, null]);
};
var getExtremumX = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getValueExtremum(params);
  }
  return getBaseExtremum(params);
};
var getExtremumY = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getBaseExtremum(params);
  }
  return getValueExtremum(params);
};

// node_modules/@mui/x-charts/esm/BarChart/formatter.js
init_extends();

// node_modules/@mui/x-charts/esm/internals/stackSeries.js
var StackOrder = {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: appearance_default,
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: ascending_default,
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: descending_default,
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked GraphsGeometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: insideOut_default,
  /**
   * Given series order [0, 1,  n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: none_default2,
  /**
   * Reverse of the given series order [n - 1, n - 2,  0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: reverse_default
};
var StackOffset = {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: expand_default,
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: diverging_default,
  /**
   * Applies a zero baseline.
   * */
  none: none_default,
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: silhouette_default,
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked GraphsGeometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: wiggle_default
};
var getStackingGroups = (params) => {
  const {
    series,
    seriesOrder,
    defaultStrategy
  } = params;
  const stackingGroups = [];
  const stackIndex = {};
  seriesOrder.forEach((id) => {
    const {
      stack,
      stackOrder,
      stackOffset
    } = series[id];
    if (stack === void 0) {
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder.none,
        stackingOffset: StackOffset.none
      });
    } else if (stackIndex[stack] === void 0) {
      stackIndex[stack] = stackingGroups.length;
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder[stackOrder ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOrder) ?? "none"],
        stackingOffset: StackOffset[stackOffset ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOffset) ?? "diverging"]
      });
    } else {
      stackingGroups[stackIndex[stack]].ids.push(id);
      if (stackOrder !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOrder = StackOrder[stackOrder];
      }
      if (stackOffset !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOffset = StackOffset[stackOffset];
      }
    }
  });
  return stackingGroups;
};

// node_modules/@mui/x-charts/esm/internals/defaultizeValueFormatter.js
init_extends();
function defaultizeValueFormatter(series, defaultValueFormatter) {
  const defaultizedSeries = {};
  Object.keys(series).forEach((seriesId) => {
    defaultizedSeries[seriesId] = _extends({}, series[seriesId], {
      valueFormatter: series[seriesId].valueFormatter ?? defaultValueFormatter
    });
  });
  return defaultizedSeries;
}

// node_modules/@mui/x-charts/esm/BarChart/formatter.js
var warnOnce = false;
var formatter = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(params);
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index) => {
        if (d3Dataset.length <= index) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index][id] = value;
        }
      });
    } else if (dataset === void 0) {
      throw new Error([`MUI X Charts: bar series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOffset,
      stackingOrder
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({
        layout: "vertical"
      }, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (!warnOnce && value !== null) {
              warnOnce = true;
              console.error([`MUI-X charts: your dataset key "${dataKey}" is used for plotting bars, but contains nonnumerical elements.`, "Bar plots only support numbers and null values."]);
            }
            return 0;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index].map(([a, b]) => [a, b])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
  };
};
var formatter_default = formatter;

// node_modules/@mui/x-charts/esm/BarChart/plugin.js
var plugin = {
  seriesType: "bar",
  seriesFormatter: formatter_default,
  colorProcessor: getColor,
  xExtremumGetter: getExtremumX,
  yExtremumGetter: getExtremumY
};

// node_modules/@mui/x-charts/esm/ScatterChart/extremums.js
var mergeMinMax = (acc, val) => {
  if (acc[0] === null || acc[1] === null) {
    return val;
  }
  if (val[0] === null || val[1] === null) {
    return acc;
  }
  return [Math.min(acc[0], val[0]), Math.max(acc[1], val[1])];
};
var getExtremumX2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => series[seriesId].xAxisKey === axis.id || series[seriesId].xAxisKey === void 0 && isDefaultAxis).reduce((acc, seriesId) => {
    const seriesMinMax = series[seriesId].data.reduce((accSeries, {
      x
    }) => {
      const val = [x, x];
      return mergeMinMax(accSeries, val);
    }, [null, null]);
    return mergeMinMax(acc, seriesMinMax);
  }, [null, null]);
};
var getExtremumY2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => series[seriesId].yAxisKey === axis.id || series[seriesId].yAxisKey === void 0 && isDefaultAxis).reduce((acc, seriesId) => {
    const seriesMinMax = series[seriesId].data.reduce((accSeries, {
      y
    }) => {
      const val = [y, y];
      return mergeMinMax(accSeries, val);
    }, [null, null]);
    return mergeMinMax(acc, seriesMinMax);
  }, [null, null]);
};

// node_modules/@mui/x-charts/esm/ScatterChart/formatter.js
var formatter2 = ({
  series,
  seriesOrder
}) => {
  return {
    series: defaultizeValueFormatter(series, (v) => `(${v.x}, ${v.y})`),
    seriesOrder
  };
};
var formatter_default2 = formatter2;

// node_modules/@mui/x-charts/esm/ScatterChart/getColor.js
function getColor2(series, xAxis, yAxis, zAxis) {
  const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (zColorScale) {
    return (dataIndex) => {
      var _a, _b;
      if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
        const color3 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
        if (color3 !== null) {
          return color3;
        }
      }
      const value = series.data[dataIndex];
      const color2 = value === null ? series.color : zColorScale(value.z);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color2 = value === null ? series.color : yColorScale(value.y);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color2 = value === null ? series.color : xColorScale(value.x);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/ScatterChart/plugin.js
var plugin2 = {
  seriesType: "scatter",
  seriesFormatter: formatter_default2,
  colorProcessor: getColor2,
  xExtremumGetter: getExtremumX2,
  yExtremumGetter: getExtremumY2
};

// node_modules/@mui/x-charts/esm/LineChart/extremums.js
var getExtremumX3 = (params) => {
  const {
    axis
  } = params;
  const minX = Math.min(...axis.data ?? []);
  const maxX = Math.max(...axis.data ?? []);
  return [minX, maxX];
};
function getSeriesExtremums(getValues, stackedData) {
  if (stackedData.length === 0) {
    return [null, null];
  }
  return stackedData.reduce((seriesAcc, stackedValue) => {
    const [base, value] = getValues(stackedValue);
    if (seriesAcc[0] === null) {
      return [Math.min(base, value), Math.max(base, value)];
    }
    return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
  }, getValues(stackedData[0]));
}
var getExtremumY3 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => series[seriesId].yAxisKey === axis.id || isDefaultAxis && series[seriesId].yAxisKey === void 0).reduce((acc, seriesId) => {
    const {
      area,
      stackedData
    } = series[seriesId];
    const isArea = area !== void 0;
    const getValues = isArea ? (d) => d : (d) => [d[1], d[1]];
    const seriesExtremums = getSeriesExtremums(getValues, stackedData);
    if (acc[0] === null) {
      return seriesExtremums;
    }
    if (seriesExtremums[0] === null) {
      return acc;
    }
    const [seriesMin, seriesMax] = seriesExtremums;
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [null, null]);
};

// node_modules/@mui/x-charts/esm/LineChart/formatter.js
init_extends();
var warnedOnce = false;
var formatter3 = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(_extends({}, params, {
    defaultStrategy: {
      stackOffset: "none"
    }
  }));
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index) => {
        if (d3Dataset.length <= index) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index][id] = value;
        }
      });
    } else if (dataset === void 0 && true) {
      throw new Error([`MUI X Charts: line series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOrder,
      stackingOffset
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({}, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (!warnedOnce && value !== null) {
              warnedOnce = true;
              console.error([`MUI-X charts: your dataset key "${dataKey}" is used for plotting line, but contains nonnumerical elements.`, "Line plots only support numbers and null values."]);
            }
            return null;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index].map(([a, b]) => [a, b])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
  };
};
var formatter_default3 = formatter3;

// node_modules/@mui/x-charts/esm/LineChart/getColor.js
function getColor3(series, xAxis, yAxis) {
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color2 = value === null ? series.color : yColorScale(value);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      var _a;
      const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
      const color2 = value === null ? series.color : xColorScale(value);
      if (color2 === null) {
        return series.color;
      }
      return color2;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/LineChart/plugin.js
var plugin3 = {
  seriesType: "line",
  colorProcessor: getColor3,
  seriesFormatter: formatter_default3,
  xExtremumGetter: getExtremumX3,
  yExtremumGetter: getExtremumY3
};

// node_modules/@mui/x-charts/esm/PieChart/formatter.js
init_extends();

// node_modules/@mui/x-charts/esm/internals/getLabel.js
function getLabel(value, location) {
  return typeof value === "function" ? value(location) : value;
}

// node_modules/@mui/x-charts/esm/PieChart/formatter.js
var getSortingComparator = (comparator = "none") => {
  if (typeof comparator === "function") {
    return comparator;
  }
  switch (comparator) {
    case "none":
      return null;
    case "desc":
      return (a, b) => b - a;
    case "asc":
      return (a, b) => a - b;
    default:
      return null;
  }
};
var formatter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  const defaultizedSeries = {};
  seriesOrder.forEach((seriesId) => {
    const arcs = pie_default().startAngle(2 * Math.PI * (series[seriesId].startAngle ?? 0) / 360).endAngle(2 * Math.PI * (series[seriesId].endAngle ?? 360) / 360).padAngle(2 * Math.PI * (series[seriesId].paddingAngle ?? 0) / 360).sortValues(getSortingComparator(series[seriesId].sortingValues ?? "none"))(series[seriesId].data.map((piePoint) => piePoint.value));
    defaultizedSeries[seriesId] = _extends({
      valueFormatter: (item) => item.value.toLocaleString()
    }, series[seriesId], {
      data: series[seriesId].data.map((item, index) => _extends({}, item, {
        id: item.id ?? `auto-generated-pie-id-${seriesId}-${index}`
      }, arcs[index])).map((item, index) => {
        var _a, _b;
        return _extends({}, item, {
          formattedValue: ((_b = (_a = series[seriesId]).valueFormatter) == null ? void 0 : _b.call(_a, _extends({}, item, {
            label: getLabel(item.label, "arc")
          }), {
            dataIndex: index
          })) ?? item.value.toLocaleString()
        });
      })
    });
  });
  return {
    seriesOrder,
    series: defaultizedSeries
  };
};
var formatter_default4 = formatter4;

// node_modules/@mui/x-charts/esm/PieChart/getColor.js
function getColor4(series) {
  return (dataIndex) => {
    return series.data[dataIndex].color;
  };
}

// node_modules/@mui/x-charts/esm/PieChart/plugin.js
var plugin4 = {
  seriesType: "pie",
  colorProcessor: getColor4,
  seriesFormatter: formatter_default4
};

// node_modules/@mui/x-charts/esm/ChartContainer/defaultPlugins.js
var defaultPlugins = [plugin, plugin2, plugin3, plugin4];

// node_modules/@mui/x-charts/esm/ChartContainer/usePluginsMerge.js
function usePluginsMerge(plugins) {
  const defaultizedPlugins = plugins ?? defaultPlugins;
  return React31.useMemo(() => {
    const seriesFormatters = {};
    const colorProcessors = {};
    const xExtremumGetters = {};
    const yExtremumGetters = {};
    for (let i = 0; i < defaultizedPlugins.length; i += 1) {
      const plugin5 = defaultizedPlugins[i];
      seriesFormatters[plugin5.seriesType] = plugin5.seriesFormatter;
      colorProcessors[plugin5.seriesType] = plugin5.colorProcessor;
      if (plugin5.xExtremumGetter) {
        xExtremumGetters[plugin5.seriesType] = plugin5.xExtremumGetter;
      }
      if (plugin5.yExtremumGetter) {
        yExtremumGetters[plugin5.seriesType] = plugin5.yExtremumGetter;
      }
    }
    return {
      seriesFormatters,
      colorProcessors,
      xExtremumGetters,
      yExtremumGetters
    };
  }, [defaultizedPlugins]);
}

// node_modules/@mui/x-charts/esm/hooks/useReducedMotion.js
var useReducedMotion = () => {
  useIsomorphicLayoutEffect(() => {
    if (!window.matchMedia) {
      globals_exports.assign({
        skipAnimation: true
      });
      return () => {
      };
    }
    const mql = window.matchMedia("(prefers-reduced-motion)");
    const handleMediaChange = (e) => {
      globals_exports.assign({
        // Modification such the react-spring implementation such that this hook can remove animation but never activate animation.
        skipAnimation: e.matches || void 0
      });
    };
    handleMediaChange(mql);
    mql.addEventListener("change", handleMediaChange);
    return () => {
      mql.removeEventListener("change", handleMediaChange);
    };
  }, []);
};

// node_modules/@mui/x-charts/esm/ChartContainer/useChartContainerHooks.js
var useChartContainerHooks = (ref, plugins) => {
  const svgRef = React32.useRef(null);
  const handleRef = useForkRef(ref, svgRef);
  const {
    xExtremumGetters,
    yExtremumGetters,
    seriesFormatters,
    colorProcessors
  } = usePluginsMerge(plugins);
  useReducedMotion();
  return {
    svgRef,
    handleRef,
    xExtremumGetters,
    yExtremumGetters,
    seriesFormatters,
    colorProcessors
  };
};

// node_modules/@mui/x-charts/esm/ChartContainer/ChartContainer.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var ChartContainer = React33.forwardRef(function ChartContainer2(props, ref) {
  const {
    width,
    height,
    series,
    margin,
    xAxis,
    yAxis,
    zAxis,
    colors,
    dataset,
    sx,
    title,
    desc,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    plugins,
    children
  } = props;
  const {
    svgRef,
    handleRef,
    xExtremumGetters,
    yExtremumGetters,
    seriesFormatters,
    colorProcessors
  } = useChartContainerHooks(ref, plugins);
  return (0, import_jsx_runtime18.jsx)(DrawingProvider, {
    width,
    height,
    margin,
    svgRef,
    children: (0, import_jsx_runtime18.jsx)(ColorProvider, {
      colorProcessors,
      children: (0, import_jsx_runtime18.jsx)(SeriesContextProvider, {
        series,
        colors,
        dataset,
        seriesFormatters,
        children: (0, import_jsx_runtime18.jsx)(CartesianContextProvider, {
          xAxis,
          yAxis,
          dataset,
          xExtremumGetters,
          yExtremumGetters,
          children: (0, import_jsx_runtime18.jsx)(ZAxisContextProvider, {
            zAxis,
            dataset,
            children: (0, import_jsx_runtime18.jsx)(InteractionProvider, {
              children: (0, import_jsx_runtime18.jsx)(HighlightedProvider, {
                highlightedItem,
                onHighlightChange,
                children: (0, import_jsx_runtime18.jsxs)(ChartsSurface, {
                  width,
                  height,
                  ref: handleRef,
                  sx,
                  title,
                  desc,
                  disableAxisListener,
                  children: [(0, import_jsx_runtime18.jsx)(ChartsAxesGradients, {}), children]
                })
              })
            })
          })
        })
      })
    })
  });
});
true ? ChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types8.default.node,
  className: import_prop_types8.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.string), import_prop_types8.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  desc: import_prop_types8.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types8.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types8.default.number.isRequired,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types8.default.shape({
    dataIndex: import_prop_types8.default.number,
    seriesId: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types8.default.shape({
    bottom: import_prop_types8.default.number,
    left: import_prop_types8.default.number,
    right: import_prop_types8.default.number,
    top: import_prop_types8.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types8.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types8.default.arrayOf(import_prop_types8.default.object).isRequired,
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  title: import_prop_types8.default.string,
  viewBox: import_prop_types8.default.shape({
    height: import_prop_types8.default.number,
    width: import_prop_types8.default.number,
    x: import_prop_types8.default.number,
    y: import_prop_types8.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types8.default.number.isRequired,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types8.default.arrayOf(import_prop_types8.default.shape({
    axisId: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]),
    classes: import_prop_types8.default.object,
    colorMap: import_prop_types8.default.oneOfType([import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      type: import_prop_types8.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types8.default.string,
      values: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number, import_prop_types8.default.string]).isRequired)
    }), import_prop_types8.default.shape({
      color: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.string.isRequired), import_prop_types8.default.func]).isRequired,
      max: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      min: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      type: import_prop_types8.default.oneOf(["continuous"]).isRequired
    }), import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      thresholds: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]).isRequired).isRequired,
      type: import_prop_types8.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types8.default.array,
    dataKey: import_prop_types8.default.string,
    disableLine: import_prop_types8.default.bool,
    disableTicks: import_prop_types8.default.bool,
    fill: import_prop_types8.default.string,
    hideTooltip: import_prop_types8.default.bool,
    id: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]),
    label: import_prop_types8.default.string,
    labelFontSize: import_prop_types8.default.number,
    labelStyle: import_prop_types8.default.object,
    max: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
    min: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
    position: import_prop_types8.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types8.default.bool,
    scaleType: import_prop_types8.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types8.default.object,
    slots: import_prop_types8.default.object,
    stroke: import_prop_types8.default.string,
    tickFontSize: import_prop_types8.default.number,
    tickInterval: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["auto"]), import_prop_types8.default.array, import_prop_types8.default.func]),
    tickLabelInterval: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["auto"]), import_prop_types8.default.func]),
    tickLabelPlacement: import_prop_types8.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types8.default.object,
    tickMaxStep: import_prop_types8.default.number,
    tickMinStep: import_prop_types8.default.number,
    tickNumber: import_prop_types8.default.number,
    tickPlacement: import_prop_types8.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types8.default.number,
    valueFormatter: import_prop_types8.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types8.default.arrayOf(import_prop_types8.default.shape({
    axisId: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]),
    classes: import_prop_types8.default.object,
    colorMap: import_prop_types8.default.oneOfType([import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      type: import_prop_types8.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types8.default.string,
      values: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number, import_prop_types8.default.string]).isRequired)
    }), import_prop_types8.default.shape({
      color: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.string.isRequired), import_prop_types8.default.func]).isRequired,
      max: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      min: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      type: import_prop_types8.default.oneOf(["continuous"]).isRequired
    }), import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      thresholds: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]).isRequired).isRequired,
      type: import_prop_types8.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types8.default.array,
    dataKey: import_prop_types8.default.string,
    disableLine: import_prop_types8.default.bool,
    disableTicks: import_prop_types8.default.bool,
    fill: import_prop_types8.default.string,
    hideTooltip: import_prop_types8.default.bool,
    id: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]),
    label: import_prop_types8.default.string,
    labelFontSize: import_prop_types8.default.number,
    labelStyle: import_prop_types8.default.object,
    max: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
    min: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
    position: import_prop_types8.default.oneOf(["left", "right"]),
    reverse: import_prop_types8.default.bool,
    scaleType: import_prop_types8.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types8.default.object,
    slots: import_prop_types8.default.object,
    stroke: import_prop_types8.default.string,
    tickFontSize: import_prop_types8.default.number,
    tickInterval: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["auto"]), import_prop_types8.default.array, import_prop_types8.default.func]),
    tickLabelInterval: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["auto"]), import_prop_types8.default.func]),
    tickLabelPlacement: import_prop_types8.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types8.default.object,
    tickMaxStep: import_prop_types8.default.number,
    tickMinStep: import_prop_types8.default.number,
    tickNumber: import_prop_types8.default.number,
    tickPlacement: import_prop_types8.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types8.default.number,
    valueFormatter: import_prop_types8.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types8.default.arrayOf(import_prop_types8.default.shape({
    colorMap: import_prop_types8.default.oneOfType([import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      type: import_prop_types8.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types8.default.string,
      values: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number, import_prop_types8.default.string]).isRequired)
    }), import_prop_types8.default.shape({
      color: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.string.isRequired), import_prop_types8.default.func]).isRequired,
      max: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      min: import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]),
      type: import_prop_types8.default.oneOf(["continuous"]).isRequired
    }), import_prop_types8.default.shape({
      colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string).isRequired,
      thresholds: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.instanceOf(Date), import_prop_types8.default.number]).isRequired).isRequired,
      type: import_prop_types8.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types8.default.array,
    dataKey: import_prop_types8.default.string,
    id: import_prop_types8.default.string,
    max: import_prop_types8.default.number,
    min: import_prop_types8.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/useChartContainerDimensions.js
var React34 = __toESM(require_react());
init_useEnhancedEffect();
init_ownerWindow();
var useChartContainerDimensions = (inWidth, inHeight) => {
  const rootRef = React34.useRef(null);
  const displayError = React34.useRef(false);
  const [width, setWidth] = React34.useState(0);
  const [height, setHeight] = React34.useState(0);
  const computeSize = React34.useCallback(() => {
    const mainEl = rootRef == null ? void 0 : rootRef.current;
    if (!mainEl) {
      return;
    }
    const win = ownerWindow(mainEl);
    const computedStyle = win.getComputedStyle(mainEl);
    const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
    const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
    setWidth(newWidth);
    setHeight(newHeight);
  }, []);
  React34.useEffect(() => {
    displayError.current = true;
  }, []);
  useEnhancedEffect_default(() => {
    if (inWidth !== void 0 && inHeight !== void 0) {
      return () => {
      };
    }
    computeSize();
    const elementToObserve = rootRef.current;
    if (typeof ResizeObserver === "undefined") {
      return () => {
      };
    }
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        computeSize();
      });
    });
    if (elementToObserve) {
      observer.observe(elementToObserve);
    }
    return () => {
      if (animationFrame) {
        window.cancelAnimationFrame(animationFrame);
      }
      if (elementToObserve) {
        observer.unobserve(elementToObserve);
      }
    };
  }, [computeSize, inHeight, inWidth]);
  if (true) {
    if (displayError.current && inWidth === void 0 && width === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`width\` prop, and its container has no \`width\` defined.`);
      displayError.current = false;
    }
    if (displayError.current && inHeight === void 0 && height === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`height\` prop, and its container has no \`height\` defined.`);
      displayError.current = false;
    }
  }
  return [rootRef, inWidth ?? width, inHeight ?? height];
};

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/ResizableContainer.js
var ResizableContainer = styled_default("div", {
  name: "MuiResponsiveChart",
  slot: "Container"
})(({
  ownerState
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexGrow: 1,
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  "&>svg": {
    width: "100%",
    height: "100%"
  }
}));

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/ResponsiveChartContainer.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var _excluded9 = ["width", "height"];
var ResponsiveChartContainer = React35.forwardRef(function ResponsiveChartContainer2(props, ref) {
  const {
    width: inWidth,
    height: inHeight
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const [containerRef, width, height] = useChartContainerDimensions(inWidth, inHeight);
  return (0, import_jsx_runtime19.jsx)(ResizableContainer, {
    ref: containerRef,
    ownerState: {
      width: inWidth,
      height: inHeight
    },
    children: width && height ? (0, import_jsx_runtime19.jsx)(ChartContainer, _extends({}, other, {
      width,
      height,
      ref
    })) : null
  });
});
true ? ResponsiveChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types9.default.node,
  className: import_prop_types9.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string), import_prop_types9.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types9.default.arrayOf(import_prop_types9.default.object),
  desc: import_prop_types9.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types9.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types9.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types9.default.shape({
    dataIndex: import_prop_types9.default.number,
    seriesId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types9.default.shape({
    bottom: import_prop_types9.default.number,
    left: import_prop_types9.default.number,
    right: import_prop_types9.default.number,
    top: import_prop_types9.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types9.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types9.default.arrayOf(import_prop_types9.default.object),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types9.default.arrayOf(import_prop_types9.default.object).isRequired,
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object]),
  title: import_prop_types9.default.string,
  viewBox: import_prop_types9.default.shape({
    height: import_prop_types9.default.number,
    width: import_prop_types9.default.number,
    x: import_prop_types9.default.number,
    y: import_prop_types9.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types9.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types9.default.arrayOf(import_prop_types9.default.shape({
    axisId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    classes: import_prop_types9.default.object,
    colorMap: import_prop_types9.default.oneOfType([import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      type: import_prop_types9.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types9.default.string,
      values: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired)
    }), import_prop_types9.default.shape({
      color: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string.isRequired), import_prop_types9.default.func]).isRequired,
      max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      type: import_prop_types9.default.oneOf(["continuous"]).isRequired
    }), import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      thresholds: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]).isRequired).isRequired,
      type: import_prop_types9.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types9.default.array,
    dataKey: import_prop_types9.default.string,
    disableLine: import_prop_types9.default.bool,
    disableTicks: import_prop_types9.default.bool,
    fill: import_prop_types9.default.string,
    hideTooltip: import_prop_types9.default.bool,
    id: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    label: import_prop_types9.default.string,
    labelFontSize: import_prop_types9.default.number,
    labelStyle: import_prop_types9.default.object,
    max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    position: import_prop_types9.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types9.default.bool,
    scaleType: import_prop_types9.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types9.default.object,
    slots: import_prop_types9.default.object,
    stroke: import_prop_types9.default.string,
    tickFontSize: import_prop_types9.default.number,
    tickInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.array, import_prop_types9.default.func]),
    tickLabelInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.func]),
    tickLabelPlacement: import_prop_types9.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types9.default.object,
    tickMaxStep: import_prop_types9.default.number,
    tickMinStep: import_prop_types9.default.number,
    tickNumber: import_prop_types9.default.number,
    tickPlacement: import_prop_types9.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types9.default.number,
    valueFormatter: import_prop_types9.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types9.default.arrayOf(import_prop_types9.default.shape({
    axisId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    classes: import_prop_types9.default.object,
    colorMap: import_prop_types9.default.oneOfType([import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      type: import_prop_types9.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types9.default.string,
      values: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired)
    }), import_prop_types9.default.shape({
      color: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string.isRequired), import_prop_types9.default.func]).isRequired,
      max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      type: import_prop_types9.default.oneOf(["continuous"]).isRequired
    }), import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      thresholds: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]).isRequired).isRequired,
      type: import_prop_types9.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types9.default.array,
    dataKey: import_prop_types9.default.string,
    disableLine: import_prop_types9.default.bool,
    disableTicks: import_prop_types9.default.bool,
    fill: import_prop_types9.default.string,
    hideTooltip: import_prop_types9.default.bool,
    id: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    label: import_prop_types9.default.string,
    labelFontSize: import_prop_types9.default.number,
    labelStyle: import_prop_types9.default.object,
    max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    position: import_prop_types9.default.oneOf(["left", "right"]),
    reverse: import_prop_types9.default.bool,
    scaleType: import_prop_types9.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types9.default.object,
    slots: import_prop_types9.default.object,
    stroke: import_prop_types9.default.string,
    tickFontSize: import_prop_types9.default.number,
    tickInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.array, import_prop_types9.default.func]),
    tickLabelInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.func]),
    tickLabelPlacement: import_prop_types9.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types9.default.object,
    tickMaxStep: import_prop_types9.default.number,
    tickMinStep: import_prop_types9.default.number,
    tickNumber: import_prop_types9.default.number,
    tickPlacement: import_prop_types9.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types9.default.number,
    valueFormatter: import_prop_types9.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types9.default.arrayOf(import_prop_types9.default.shape({
    colorMap: import_prop_types9.default.oneOfType([import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      type: import_prop_types9.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types9.default.string,
      values: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired)
    }), import_prop_types9.default.shape({
      color: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string.isRequired), import_prop_types9.default.func]).isRequired,
      max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      type: import_prop_types9.default.oneOf(["continuous"]).isRequired
    }), import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      thresholds: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]).isRequired).isRequired,
      type: import_prop_types9.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types9.default.array,
    dataKey: import_prop_types9.default.string,
    id: import_prop_types9.default.string,
    max: import_prop_types9.default.number,
    min: import_prop_types9.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
init_extends();
var React40 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
init_objectWithoutPropertiesLoose();
init_extends();
var React38 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-charts/esm/ChartsAxis/axisClasses.js
init_utils();
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);

// node_modules/@mui/x-charts/esm/internals/components/AxisSharedComponents.js
init_extends();
var AxisRoot = styled_default("g", {
  name: "MuiChartsAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: _extends({}, theme.typography.body1, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
init_extends();
init_objectWithoutPropertiesLoose();
var React36 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/esm/internals/getWordsByLines.js
init_extends();

// node_modules/@mui/x-charts/esm/internals/domUtils.js
init_extends();
function isSsr() {
  return typeof window === "undefined";
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "mui_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return `${value}px`;
  }
  return value;
}
function camelToMiddleLine(text) {
  const strs = text.split("");
  const formatStrs = strs.reduce((result, entry) => {
    if (entry === entry.toUpperCase()) {
      return [...result, "-", entry.toLowerCase()];
    }
    return [...result, entry];
  }, []);
  return formatStrs.join("");
}
var getStyleString = (style) => Object.keys(style).sort().reduce((result, s) => `${result}${camelToMiddleLine(s)}:${autoCompleteStyle(s, style[s])};`, "");
var getStringSize = (text, style = {}) => {
  if (text === void 0 || text === null || isSsr()) {
    return {
      width: 0,
      height: 0
    };
  }
  const str = `${text}`;
  const styleString = getStyleString(style);
  const cacheKey = `${str}-${styleString}`;
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (measurementSpan === null) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    const measurementSpanStyle = _extends({}, SPAN_STYLE, style);
    Object.keys(measurementSpanStyle).map((styleKey) => {
      measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
      return styleKey;
    });
    measurementSpan.textContent = str;
    const rect = measurementSpan.getBoundingClientRect();
    const result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (stringCache.cacheCount + 1 > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    } else {
      stringCache.cacheCount += 1;
    }
    return result;
  } catch (e) {
    return {
      width: 0,
      height: 0
    };
  }
};

// node_modules/@mui/x-charts/esm/internals/getWordsByLines.js
function getWordsByLines({
  style,
  needsComputation,
  text
}) {
  return text.split("\n").map((subText) => _extends({
    text: subText
  }, needsComputation ? getStringSize(subText, style) : {
    width: 0,
    height: 0
  }));
}

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var _excluded10 = ["x", "y", "style", "text", "ownerState"];
var _excluded23 = ["angle", "textAnchor", "dominantBaseline"];
function ChartsText(props) {
  const {
    x,
    y,
    style: styleProps,
    text
  } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded10);
  const _ref = styleProps ?? {}, {
    angle,
    textAnchor,
    dominantBaseline
  } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded23);
  const wordsByLines = React36.useMemo(() => getWordsByLines({
    style,
    needsComputation: text.includes("\n"),
    text
  }), [style, text]);
  let startDy;
  switch (dominantBaseline) {
    case "hanging":
      startDy = 0;
      break;
    case "central":
      startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
      break;
    default:
      startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
      break;
  }
  const transforms = [];
  if (angle) {
    transforms.push(`rotate(${angle}, ${x}, ${y})`);
  }
  return (0, import_jsx_runtime20.jsx)("text", _extends({}, textProps, {
    transform: transforms.length > 0 ? transforms.join(" ") : void 0,
    x,
    y,
    textAnchor,
    dominantBaseline,
    style,
    children: wordsByLines.map((line, index) => (0, import_jsx_runtime20.jsx)("tspan", {
      x,
      dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
      dominantBaseline,
      children: line.text
    }, index))
  }));
}
true ? ChartsText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types10.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types10.default.bool,
  ownerState: import_prop_types10.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types10.default.object,
  /**
   * Text displayed.
   */
  text: import_prop_types10.default.string.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/internals/geometry.js
var ANGLE_APPROX = 5;
var warnedOnce2 = false;
function getMinXTranslation(width, height, angle = 0) {
  if (true) {
    if (!warnedOnce2 && angle > 90 && angle < -90) {
      warnedOnce2 = true;
      console.warn([`MUI X Charts: It seems you applied an angle larger than 90 or smaller than -90 to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`].join("\n"));
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height;
  }
  const radAngle = standardAngle * Math.PI / 180;
  const angleSwich = Math.atan2(height, width);
  if (radAngle < angleSwich) {
    return width / Math.cos(radAngle);
  }
  return height / Math.sin(radAngle);
}

// node_modules/@mui/x-charts/esm/hooks/useMounted.js
var React37 = __toESM(require_react());
init_useEnhancedEffect();
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React37.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React37.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var _excluded11 = ["scale", "tickNumber", "reverse"];
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
function addLabelDimension(xTicks, {
  tickLabelStyle: style,
  tickLabelInterval,
  reverse,
  isMounted
}) {
  const withDimension = xTicks.map((tick) => {
    if (!isMounted || tick.formattedValue === void 0) {
      return _extends({}, tick, {
        width: 0,
        height: 0
      });
    }
    const tickSizes = getWordsByLines({
      style,
      needsComputation: true,
      text: tick.formattedValue
    });
    return _extends({}, tick, {
      width: Math.max(...tickSizes.map((size) => size.width)),
      height: Math.max(tickSizes.length * tickSizes[0].height)
    });
  });
  if (typeof tickLabelInterval === "function") {
    return withDimension.map((item, index) => _extends({}, item, {
      skipLabel: !tickLabelInterval(item.value, index)
    }));
  }
  let currentTextLimit = 0;
  let previousTextLimit = 0;
  const direction = reverse ? -1 : 1;
  return withDimension.map((item, labelIndex) => {
    const {
      width,
      offset,
      labelOffset,
      height
    } = item;
    const distance = getMinXTranslation(width, height, style == null ? void 0 : style.angle);
    const textPosition = offset + labelOffset;
    const gapRatio = 1.2;
    currentTextLimit = textPosition - direction * (gapRatio * distance) / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * previousTextLimit) {
      return _extends({}, item, {
        skipLabel: true
      });
    }
    previousTextLimit = textPosition + direction * (gapRatio * distance) / 2;
    return item;
  });
}
var defaultProps = {
  position: "bottom",
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};
function ChartsXAxis(inProps) {
  const {
    xAxisIds,
    xAxis
  } = useCartesianContext();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded11);
  const isMounted = useMounted();
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickLabelStyle,
    label,
    labelStyle,
    tickFontSize,
    labelFontSize,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement
  } = defaultizedProps;
  const theme = useTheme();
  const classes = useUtilityClasses3(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const positionSign = position === "bottom" ? 1 : -1;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const axisTickLabelProps = useSlotProps({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto",
        fontSize: tickFontSize ?? 12
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  });
  const xTicksWithDimension = addLabelDimension(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    reverse,
    isMounted
  });
  const labelRefPoint = {
    x: left + width / 2,
    y: positionSign * (tickSize + 22)
  };
  const axisLabelProps = useSlotProps({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize ?? 14,
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = xScale.domain();
  if (domain.length === 0 || domain[0] === domain[1]) {
    return null;
  }
  return (0, import_jsx_runtime21.jsxs)(AxisRoot, {
    transform: `translate(0, ${position === "bottom" ? top + height : top})`,
    className: classes.root,
    children: [!disableLine && (0, import_jsx_runtime21.jsx)(Line, _extends({
      x1: left,
      x2: left + width,
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), xTicksWithDimension.filter((tick) => tick.offset >= left - 1 && tick.offset <= left + width + 1).map(({
      formattedValue,
      offset,
      labelOffset,
      skipLabel
    }, index) => {
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + 3);
      const showTick = offset >= left - 1 && offset <= left + width + 1;
      const showTickLabel = offset + xTickLabel >= left - 1 && offset + xTickLabel <= left + width + 1;
      return (0, import_jsx_runtime21.jsxs)("g", {
        transform: `translate(${offset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime21.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && showTickLabel && (0, import_jsx_runtime21.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: formattedValue.toString()
        }))]
      }, index);
    }), label && (0, import_jsx_runtime21.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime21.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types11.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types11.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types11.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types11.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types11.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types11.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types11.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types11.default.oneOf(["bottom", "top"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types11.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types11.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types11.default.string,
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types11.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["auto"]), import_prop_types11.default.array, import_prop_types11.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["auto"]), import_prop_types11.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types11.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types11.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types11.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types11.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types11.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types11.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types11.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxis.js
init_extends();
init_objectWithoutPropertiesLoose();
var React39 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());
init_utils();
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var _excluded12 = ["scale", "tickNumber"];
var useUtilityClasses4 = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var defaultProps2 = {
  position: "left",
  disableLine: false,
  disableTicks: false,
  tickFontSize: 12,
  labelFontSize: 14,
  tickSize: 6
};
function ChartsYAxis(inProps) {
  const {
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded12);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickFontSize,
    label,
    labelFontSize,
    labelStyle,
    tickLabelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval
  } = defaultizedProps;
  const theme = useTheme();
  const isRTL = theme.direction === "rtl";
  const classes = useUtilityClasses4(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval
  });
  const positionSign = position === "right" ? 1 : -1;
  const labelRefPoint = {
    x: positionSign * (tickFontSize + tickSize + 10),
    y: top + height / 2
  };
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const revertAnchor = !isRTL && position === "right" || isRTL && position !== "right";
  const axisTickLabelProps = useSlotProps({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        fontSize: tickFontSize,
        textAnchor: revertAnchor ? "start" : "end",
        dominantBaseline: "central"
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const axisLabelProps = useSlotProps({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = yScale.domain();
  if (domain.length === 0 || domain[0] === domain[1]) {
    return null;
  }
  return (0, import_jsx_runtime22.jsxs)(AxisRoot, {
    transform: `translate(${position === "right" ? left + width : left}, 0)`,
    className: classes.root,
    children: [!disableLine && (0, import_jsx_runtime22.jsx)(Line, _extends({
      y1: yScale.range()[0],
      y2: yScale.range()[1],
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), yTicks.map(({
      formattedValue,
      offset,
      labelOffset,
      value
    }, index) => {
      const xTickLabel = positionSign * (tickSize + 2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
      return (0, import_jsx_runtime22.jsxs)("g", {
        transform: `translate(0, ${offset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime22.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && (0, import_jsx_runtime22.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: formattedValue.toString()
        }, axisTickLabelProps))]
      }, index);
    }), label && (0, import_jsx_runtime22.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime22.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types12.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types12.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types12.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types12.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types12.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types12.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types12.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types12.default.oneOf(["left", "right"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types12.default.string,
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types12.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["auto"]), import_prop_types12.default.array, import_prop_types12.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["auto"]), import_prop_types12.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types12.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types12.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types12.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types12.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types12.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types12.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types12.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var getAxisId = (propsValue, defaultAxisId) => {
  if (propsValue == null) {
    return null;
  }
  if (typeof propsValue === "object") {
    return propsValue.axisId ?? defaultAxisId ?? null;
  }
  return propsValue;
};
var mergeProps = (axisConfig, slots, slotProps) => {
  return typeof axisConfig === "object" ? _extends({}, axisConfig, {
    slots: _extends({}, slots, axisConfig == null ? void 0 : axisConfig.slots),
    slotProps: _extends({}, slotProps, axisConfig == null ? void 0 : axisConfig.slotProps)
  }) : {
    slots,
    slotProps
  };
};
function ChartsAxis(props) {
  const {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  } = props;
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const leftId = getAxisId(leftAxis === void 0 ? yAxisIds[0] : leftAxis, yAxisIds[0]);
  const bottomId = getAxisId(bottomAxis === void 0 ? xAxisIds[0] : bottomAxis, xAxisIds[0]);
  const topId = getAxisId(topAxis, xAxisIds[0]);
  const rightId = getAxisId(rightAxis, yAxisIds[0]);
  if (topId !== null && !xAxis[topId]) {
    throw Error([`MUI X Charts: id used for top axis "${topId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  if (leftId !== null && !yAxis[leftId]) {
    throw Error([`MUI X Charts: id used for left axis "${leftId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (rightId !== null && !yAxis[rightId]) {
    throw Error([`MUI X Charts: id used for right axis "${rightId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (bottomId !== null && !xAxis[bottomId]) {
    throw Error([`MUI X Charts: id used for bottom axis "${bottomId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  const topAxisProps = mergeProps(topAxis, slots, slotProps);
  const bottomAxisProps = mergeProps(bottomAxis, slots, slotProps);
  const leftAxisProps = mergeProps(leftAxis, slots, slotProps);
  const rightAxisProps = mergeProps(rightAxis, slots, slotProps);
  return (0, import_jsx_runtime23.jsxs)(React40.Fragment, {
    children: [topId && (0, import_jsx_runtime23.jsx)(ChartsXAxis, _extends({}, topAxisProps, {
      position: "top",
      axisId: topId
    })), bottomId && (0, import_jsx_runtime23.jsx)(ChartsXAxis, _extends({}, bottomAxisProps, {
      position: "bottom",
      axisId: bottomId
    })), leftId && (0, import_jsx_runtime23.jsx)(ChartsYAxis, _extends({}, leftAxisProps, {
      position: "left",
      axisId: leftId
    })), rightId && (0, import_jsx_runtime23.jsx)(ChartsYAxis, _extends({}, rightAxisProps, {
      position: "right",
      axisId: rightId
    }))]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types13.default.oneOfType([import_prop_types13.default.object, import_prop_types13.default.string]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types13.default.oneOfType([import_prop_types13.default.object, import_prop_types13.default.string]),
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types13.default.oneOfType([import_prop_types13.default.object, import_prop_types13.default.string]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types13.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types13.default.object,
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types13.default.oneOfType([import_prop_types13.default.object, import_prop_types13.default.string])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
init_extends();
var React47 = __toESM(require_react());
var import_prop_types16 = __toESM(require_prop_types());
init_composeClasses();

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
init_extends();
var React41 = __toESM(require_react());
function generateVirtualElement(mousePosition) {
  if (mousePosition === null) {
    return {
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        toJSON: () => ""
      })
    };
  }
  const {
    x,
    y
  } = mousePosition;
  const boundingBox = {
    width: 0,
    height: 0,
    x,
    y,
    top: y,
    right: x,
    bottom: y,
    left: x
  };
  return {
    getBoundingClientRect: () => _extends({}, boundingBox, {
      toJSON: () => JSON.stringify(boundingBox)
    })
  };
}
function useMouseTracker() {
  const svgRef = useSvgRef();
  const [mousePosition, setMousePosition] = React41.useState(null);
  React41.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = () => {
      setMousePosition(null);
    };
    const handleMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY,
        height: event.height,
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerdown", handleMove);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleMove);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return mousePosition;
}
function getTooltipHasData(trigger, displayedData) {
  if (trigger === "item") {
    return displayedData !== null;
  }
  const hasAxisXData = displayedData.x !== null;
  const hasAxisYData = displayedData.y !== null;
  return hasAxisXData || hasAxisYData;
}
function utcFormatter(v) {
  if (v instanceof Date) {
    return v.toUTCString();
  }
  return v.toLocaleString();
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
init_extends();
var React44 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsItemTooltipContent.js
init_extends();
var React42 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());
init_clsx();

// node_modules/@mui/x-charts/esm/ChartsTooltip/chartsTooltipClasses.js
init_utils();
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container"
})(({
  theme
}) => ({
  boxShadow: theme.shadows[1],
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  borderRadius: theme.shape.borderRadius
}));
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme
}) => ({
  borderSpacing: 0,
  "& thead td": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(1)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(1)
  }
}));
var ChartsTooltipCell = styled_default("td", {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${chartsTooltipClasses.labelCell}`]: {
    paddingLeft: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(4),
    color: (theme.vars || theme).palette.text.primary
  },
  "td:first-of-type&": {
    paddingLeft: theme.spacing(2)
  },
  "td:last-of-type&": {
    paddingRight: theme.spacing(2)
  }
}));
var ChartsTooltipMark = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Mark",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
})(({
  theme,
  color: color2
}) => ({
  width: theme.spacing(1),
  height: theme.spacing(1),
  borderRadius: "50%",
  boxShadow: theme.shadows[1],
  backgroundColor: color2,
  borderColor: (theme.vars || theme).palette.background.paper,
  border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
  boxSizing: "content-box"
}));

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsItemTooltipContent.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
function DefaultChartsItemTooltipContent(props) {
  var _a;
  const {
    series,
    itemData,
    sx,
    classes,
    getColor: getColor5
  } = props;
  if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
    return null;
  }
  const {
    displayedLabel,
    color: color2
  } = series.type === "pie" ? {
    color: getColor5(itemData.dataIndex),
    displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  } : {
    color: getColor5(itemData.dataIndex),
    displayedLabel: getLabel(series.label, "tooltip")
  };
  const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
    label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  }) : series.data[itemData.dataIndex];
  const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
    dataIndex: itemData.dataIndex
  });
  return (0, import_jsx_runtime24.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.root,
    children: (0, import_jsx_runtime24.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime24.jsx)("tbody", {
        children: (0, import_jsx_runtime24.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime24.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.markCell, classes.cell),
            children: (0, import_jsx_runtime24.jsx)(ChartsTooltipMark, {
              color: color2,
              className: classes.mark
            })
          }), (0, import_jsx_runtime24.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            children: displayedLabel
          }), (0, import_jsx_runtime24.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? DefaultChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types14.default.object.isRequired,
  /**
   * Get the color of the item with index `dataIndex`.
   * @param {number} dataIndex The data index of the item.
   * @returns {string} The color to display.
   */
  getColor: import_prop_types14.default.func.isRequired,
  /**
   * The data used to identify the triggered item.
   */
  itemData: import_prop_types14.default.shape({
    dataIndex: import_prop_types14.default.number,
    seriesId: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]).isRequired,
    type: import_prop_types14.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
  }).isRequired,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types14.default.object.isRequired,
  sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/hooks/useColor.js
var React43 = __toESM(require_react());
function useColorProcessor(seriesType) {
  const colorProcessors = React43.useContext(ColorContext);
  if (!seriesType) {
    return colorProcessors;
  }
  return colorProcessors[seriesType];
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
function ChartsItemTooltipContent(props) {
  var _a;
  const {
    content,
    itemData,
    sx,
    classes,
    contentProps
  } = props;
  const series = useSeries()[itemData.type].series[itemData.seriesId];
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React44.useContext(ZAxisContext);
  const colorProcessors = useColorProcessor();
  const xAxisKey = series.xAxisKey ?? xAxisIds[0];
  const yAxisKey = series.yAxisKey ?? yAxisIds[0];
  const zAxisKey = series.zAxisKey ?? zAxisIds[0];
  const getColor5 = ((_a = colorProcessors[series.type]) == null ? void 0 : _a.call(colorProcessors, series, xAxisKey && xAxis[xAxisKey], yAxisKey && yAxis[yAxisKey], zAxisKey && zAxis[zAxisKey])) ?? (() => "");
  const Content = content ?? DefaultChartsItemTooltipContent;
  const chartTooltipContentProps = useSlotProps({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      itemData,
      series,
      sx,
      classes,
      getColor: getColor5
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime25.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
init_extends();
var React46 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var React45 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());
init_clsx();

// node_modules/@mui/x-charts/esm/internals/configInit.js
var instance;
var CartesianSeriesTypes = class {
  constructor() {
    this.types = /* @__PURE__ */ new Set();
    if (instance) {
      throw new Error("You can only create one instance!");
    }
    instance = this.types;
  }
  addType(value) {
    this.types.add(value);
  }
  getTypes() {
    return this.types;
  }
};
var cartesianSeriesTypes = new CartesianSeriesTypes();
cartesianSeriesTypes.addType("bar");
cartesianSeriesTypes.addType("line");
cartesianSeriesTypes.addType("scatter");

// node_modules/@mui/x-charts/esm/internals/isCartesian.js
function isCartesianSeriesType(seriesType) {
  return cartesianSeriesTypes.getTypes().has(seriesType);
}
function isCartesianSeries(series) {
  return isCartesianSeriesType(series.type);
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
function DefaultChartsAxisTooltipContent(props) {
  const {
    series,
    axis,
    dataIndex,
    axisValue,
    sx,
    classes
  } = props;
  if (dataIndex == null) {
    return null;
  }
  const axisFormatter = axis.valueFormatter ?? ((v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString());
  return (0, import_jsx_runtime26.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.root,
    children: (0, import_jsx_runtime26.jsxs)(ChartsTooltipTable, {
      className: classes.table,
      children: [axisValue != null && !axis.hideTooltip && (0, import_jsx_runtime26.jsx)("thead", {
        children: (0, import_jsx_runtime26.jsx)(ChartsTooltipRow, {
          children: (0, import_jsx_runtime26.jsx)(ChartsTooltipCell, {
            colSpan: 3,
            children: (0, import_jsx_runtime26.jsx)(Typography_default, {
              children: axisFormatter(axisValue, {
                location: "tooltip"
              })
            })
          })
        })
      }), (0, import_jsx_runtime26.jsx)("tbody", {
        children: series.filter(isCartesianSeries).map(({
          id,
          label,
          valueFormatter,
          data,
          getColor: getColor5
        }) => {
          const formattedValue = valueFormatter(data[dataIndex] ?? null, {
            dataIndex
          });
          if (formattedValue == null) {
            return null;
          }
          const formattedLabel = getLabel(label, "tooltip");
          const color2 = getColor5(dataIndex);
          return (0, import_jsx_runtime26.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime26.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.markCell, classes.cell),
              children: color2 && (0, import_jsx_runtime26.jsx)(ChartsTooltipMark, {
                color: color2,
                className: classes.mark
              })
            }), (0, import_jsx_runtime26.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              children: formattedLabel ? (0, import_jsx_runtime26.jsx)(Typography_default, {
                children: formattedLabel
              }) : null
            }), (0, import_jsx_runtime26.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              children: (0, import_jsx_runtime26.jsx)(Typography_default, {
                children: formattedValue
              })
            })]
          }, id);
        })
      })]
    })
  });
}
true ? DefaultChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The properties of the triggered axis.
   */
  axis: import_prop_types15.default.object.isRequired,
  /**
   * Data identifying the triggered axis.
   */
  axisData: import_prop_types15.default.shape({
    x: import_prop_types15.default.shape({
      index: import_prop_types15.default.number,
      value: import_prop_types15.default.oneOfType([import_prop_types15.default.instanceOf(Date), import_prop_types15.default.number, import_prop_types15.default.string]).isRequired
    }),
    y: import_prop_types15.default.shape({
      index: import_prop_types15.default.number,
      value: import_prop_types15.default.oneOfType([import_prop_types15.default.instanceOf(Date), import_prop_types15.default.number, import_prop_types15.default.string]).isRequired
    })
  }).isRequired,
  /**
   * The value associated to the current mouse position.
   */
  axisValue: import_prop_types15.default.oneOfType([import_prop_types15.default.instanceOf(Date), import_prop_types15.default.number, import_prop_types15.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types15.default.object.isRequired,
  /**
   * The index of the data item triggered.
   */
  dataIndex: import_prop_types15.default.number,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types15.default.arrayOf(import_prop_types15.default.object).isRequired,
  sx: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object, import_prop_types15.default.bool])), import_prop_types15.default.func, import_prop_types15.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
function ChartsAxisTooltipContent(props) {
  const {
    content,
    contentProps,
    axisData,
    sx,
    classes
  } = props;
  const isXaxis = (axisData.x && axisData.x.index) !== void 0;
  const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
  const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const {
    zAxisIds,
    zAxis
  } = React46.useContext(ZAxisContext);
  const series = useSeries();
  const colorProcessors = useColorProcessor();
  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
  const relevantSeries = React46.useMemo(() => {
    const rep = [];
    Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
      series[seriesType].seriesOrder.forEach((seriesId) => {
        var _a;
        const item = series[seriesType].series[seriesId];
        const axisKey = isXaxis ? item.xAxisKey : item.yAxisKey;
        if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
          const seriesToAdd = series[seriesType].series[seriesId];
          const zAxisKey = seriesToAdd.zAxisKey ?? zAxisIds[0];
          const getColor5 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[seriesToAdd.xAxisKey ?? xAxisIds[0]], yAxis[seriesToAdd.yAxisKey ?? yAxisIds[0]], zAxisKey && zAxis[zAxisKey])) ?? (() => "");
          rep.push(_extends({}, seriesToAdd, {
            getColor: getColor5
          }));
        }
      });
    });
    return rep;
  }, [USED_AXIS_ID, colorProcessors, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
  const relevantAxis = React46.useMemo(() => {
    return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
  }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
  const Content = content ?? DefaultChartsAxisTooltipContent;
  const chartTooltipContentProps = useSlotProps({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      axisData,
      series: relevantSeries,
      axis: relevantAxis,
      dataIndex,
      axisValue,
      sx,
      classes
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime27.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var useUtilityClasses5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markCell: ["markCell"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};
var ChartsTooltipRoot = styled_default(Popper, {
  name: "MuiChartsTooltip",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltip(props) {
  const themeProps = useThemeProps({
    props,
    name: "MuiChartsTooltip"
  });
  const {
    trigger = "axis",
    itemContent,
    axisContent,
    slots,
    slotProps
  } = themeProps;
  const mousePosition = useMouseTracker();
  const {
    item,
    axis
  } = React47.useContext(InteractionContext);
  const displayedData = trigger === "item" ? item : axis;
  const tooltipHasData = getTooltipHasData(trigger, displayedData);
  const popperOpen = mousePosition !== null && tooltipHasData;
  const classes = useUtilityClasses5({
    classes: themeProps.classes
  });
  const PopperComponent = (slots == null ? void 0 : slots.popper) ?? ChartsTooltipRoot;
  const popperProps = useSlotProps({
    elementType: PopperComponent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      open: popperOpen,
      placement: (mousePosition == null ? void 0 : mousePosition.pointerType) === "mouse" ? "right-start" : "top",
      anchorEl: generateVirtualElement(mousePosition),
      modifiers: [{
        name: "offset",
        options: {
          offset: [0, (mousePosition == null ? void 0 : mousePosition.pointerType) === "touch" ? 40 - mousePosition.height : 0]
        }
      }]
    },
    ownerState: {}
  });
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime28.jsx)(NoSsr, {
    children: popperOpen && (0, import_jsx_runtime28.jsx)(PopperComponent, _extends({}, popperProps, {
      children: trigger === "item" ? (0, import_jsx_runtime28.jsx)(ChartsItemTooltipContent, {
        itemData: displayedData,
        content: (slots == null ? void 0 : slots.itemContent) ?? itemContent,
        contentProps: slotProps == null ? void 0 : slotProps.itemContent,
        sx: {
          mx: 2
        },
        classes
      }) : (0, import_jsx_runtime28.jsx)(ChartsAxisTooltipContent, {
        axisData: displayedData,
        content: (slots == null ? void 0 : slots.axisContent) ?? axisContent,
        contentProps: slotProps == null ? void 0 : slotProps.axisContent,
        sx: {
          mx: 2
        },
        classes
      })
    }))
  });
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Component to override the tooltip content when trigger is set to 'axis'.
   * @deprecated Use slots.axisContent instead
   */
  axisContent: import_prop_types16.default.elementType,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types16.default.object,
  /**
   * Component to override the tooltip content when trigger is set to 'item'.
   * @deprecated Use slots.itemContent instead
   */
  itemContent: import_prop_types16.default.elementType,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types16.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types16.default.object,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'item'
   */
  trigger: import_prop_types16.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
init_extends();
var React49 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-charts/esm/BarChart/legend.js
var legendGetter = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default = legendGetter;

// node_modules/@mui/x-charts/esm/ScatterChart/legend.js
var legendGetter2 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default2 = legendGetter2;

// node_modules/@mui/x-charts/esm/LineChart/legend.js
var legendGetter3 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default3 = legendGetter3;

// node_modules/@mui/x-charts/esm/PieChart/legend.js
var legendGetter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    series[seriesId].data.forEach((item) => {
      const formattedLabel = getLabel(item.label, "legend");
      if (formattedLabel === void 0) {
        return;
      }
      acc.push({
        color: item.color,
        label: formattedLabel,
        id: item.id
      });
    });
    return acc;
  }, []);
};
var legend_default4 = legendGetter4;

// node_modules/@mui/x-charts/esm/ChartsLegend/utils.js
var legendGetter5 = {
  bar: legend_default,
  scatter: legend_default2,
  line: legend_default3,
  pie: legend_default4
};
function getSeriesToDisplay(series) {
  return Object.keys(series).flatMap((seriesType) => {
    const getter = legendGetter5[seriesType];
    return getter === void 0 ? [] : getter(series[seriesType]);
  });
}

// node_modules/@mui/x-charts/esm/ChartsLegend/chartsLegendClasses.js
init_utils();
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "series", "mark", "label", "column", "row"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/DefaultChartsLegend.js
init_objectWithoutPropertiesLoose();
init_extends();
var React48 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var _excluded13 = ["rotate", "dominantBaseline"];
var _excluded24 = ["label"];
var ChartsLegendRoot = styled_default("g", {
  name: "MuiChartsLegend",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var getStandardizedPadding = (padding) => {
  if (typeof padding === "number") {
    return {
      left: padding,
      right: padding,
      top: padding,
      bottom: padding
    };
  }
  return _extends({
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  }, padding);
};
function DefaultChartsLegend(props) {
  const {
    hidden,
    position,
    direction,
    seriesToDisplay,
    drawingArea,
    classes,
    itemMarkWidth = 20,
    itemMarkHeight = 20,
    markGap = 5,
    itemGap = 10,
    padding: paddingProps = 10,
    labelStyle: inLabelStyle
  } = props;
  const theme = useTheme();
  const isRTL = theme.direction === "rtl";
  const labelStyle = React48.useMemo(
    () => _extends({}, theme.typography.subtitle1, {
      color: "inherit",
      dominantBaseline: "central",
      textAnchor: "start",
      fill: (theme.vars || theme).palette.text.primary,
      lineHeight: 1
    }, inLabelStyle),
    // To say to TS that the dominantBaseline and textAnchor are correct
    [inLabelStyle, theme]
  );
  const padding = React48.useMemo(() => getStandardizedPadding(paddingProps), [paddingProps]);
  const getItemSpace = React48.useCallback((label, inStyle = {}) => {
    const style = _objectWithoutPropertiesLoose(inStyle, _excluded13);
    const linesSize = getWordsByLines({
      style,
      needsComputation: true,
      text: label
    });
    const innerSize = {
      innerWidth: itemMarkWidth + markGap + Math.max(...linesSize.map((size) => size.width)),
      innerHeight: Math.max(itemMarkHeight, linesSize.length * linesSize[0].height)
    };
    return _extends({}, innerSize, {
      outerWidth: innerSize.innerWidth + itemGap,
      outerHeight: innerSize.innerHeight + itemGap
    });
  }, [itemGap, itemMarkHeight, itemMarkWidth, markGap]);
  const totalWidth = drawingArea.left + drawingArea.width + drawingArea.right;
  const totalHeight = drawingArea.top + drawingArea.height + drawingArea.bottom;
  const availableWidth = totalWidth - padding.left - padding.right;
  const availableHeight = totalHeight - padding.top - padding.bottom;
  const [seriesWithPosition, legendWidth, legendHeight] = React48.useMemo(() => {
    let x = 0;
    let y = 0;
    let totalWidthUsed = 0;
    let totalHeightUsed = 0;
    let rowIndex = 0;
    const rowMaxHeight = [0];
    const seriesWithRawPosition = seriesToDisplay.map((_ref) => {
      let {
        label
      } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded24);
      const itemSpace = getItemSpace(label, labelStyle);
      const rep = _extends({}, other, {
        label,
        positionX: x,
        positionY: y,
        innerHeight: itemSpace.innerHeight,
        innerWidth: itemSpace.innerWidth,
        outerHeight: itemSpace.outerHeight,
        outerWidth: itemSpace.outerWidth,
        rowIndex
      });
      if (direction === "row") {
        if (x + itemSpace.innerWidth > availableWidth) {
          x = 0;
          y += rowMaxHeight[rowIndex];
          rowIndex += 1;
          if (rowMaxHeight.length <= rowIndex) {
            rowMaxHeight.push(0);
          }
          rep.positionX = x;
          rep.positionY = y;
          rep.rowIndex = rowIndex;
        }
        totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
        rowMaxHeight[rowIndex] = Math.max(rowMaxHeight[rowIndex], itemSpace.outerHeight);
        x += itemSpace.outerWidth;
      }
      if (direction === "column") {
        if (y + itemSpace.innerHeight > availableHeight) {
          x = totalWidthUsed + itemGap;
          y = 0;
          rowIndex = 0;
          rep.positionX = x;
          rep.positionY = y;
          rep.rowIndex = rowIndex;
        }
        if (rowMaxHeight.length <= rowIndex) {
          rowMaxHeight.push(0);
        }
        totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
        rowIndex += 1;
        y += itemSpace.outerHeight;
      }
      return rep;
    });
    return [seriesWithRawPosition.map((item) => _extends({}, item, {
      positionY: item.positionY + (direction === "row" ? rowMaxHeight[item.rowIndex] / 2 : item.outerHeight / 2)
      // Get the center of the item
    })), totalWidthUsed, totalHeightUsed];
  }, [seriesToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap]);
  const gapX = React48.useMemo(() => {
    switch (position.horizontal) {
      case "left":
        return padding.left;
      case "right":
        return totalWidth - padding.right - legendWidth;
      default:
        return (totalWidth - legendWidth) / 2;
    }
  }, [position.horizontal, padding.left, padding.right, totalWidth, legendWidth]);
  const gapY = React48.useMemo(() => {
    switch (position.vertical) {
      case "top":
        return padding.top;
      case "bottom":
        return totalHeight - padding.bottom - legendHeight;
      default:
        return (totalHeight - legendHeight) / 2;
    }
  }, [position.vertical, padding.top, padding.bottom, totalHeight, legendHeight]);
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime29.jsx)(NoSsr, {
    children: (0, import_jsx_runtime29.jsx)(ChartsLegendRoot, {
      className: classes.root,
      children: seriesWithPosition.map(({
        id,
        label,
        color: color2,
        positionX,
        positionY
      }) => (0, import_jsx_runtime29.jsxs)("g", {
        className: classes.series,
        transform: `translate(${gapX + (isRTL ? legendWidth - positionX : positionX)} ${gapY + positionY})`,
        children: [(0, import_jsx_runtime29.jsx)("rect", {
          className: classes.mark,
          x: isRTL ? -itemMarkWidth : 0,
          y: -itemMarkHeight / 2,
          width: itemMarkWidth,
          height: itemMarkHeight,
          fill: color2
        }), (0, import_jsx_runtime29.jsx)(ChartsText, {
          style: labelStyle,
          text: label,
          x: (isRTL ? -1 : 1) * (itemMarkWidth + markGap),
          y: 0
        })]
      }, id))
    })
  });
}
true ? DefaultChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types17.default.object.isRequired,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types17.default.oneOf(["column", "row"]).isRequired,
  drawingArea: import_prop_types17.default.shape({
    bottom: import_prop_types17.default.number.isRequired,
    height: import_prop_types17.default.number.isRequired,
    left: import_prop_types17.default.number.isRequired,
    right: import_prop_types17.default.number.isRequired,
    top: import_prop_types17.default.number.isRequired,
    width: import_prop_types17.default.number.isRequired
  }).isRequired,
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types17.default.bool,
  /**
   * Space between two legend items (in px).
   * @default 10
   */
  itemGap: import_prop_types17.default.number,
  /**
   * Height of the item mark (in px).
   * @default 20
   */
  itemMarkHeight: import_prop_types17.default.number,
  /**
   * Width of the item mark (in px).
   * @default 20
   */
  itemMarkWidth: import_prop_types17.default.number,
  /**
   * Style applied to legend labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types17.default.object,
  /**
   * Space between the mark and the label (in px).
   * @default 5
   */
  markGap: import_prop_types17.default.number,
  /**
   * Legend padding (in px).
   * Can either be a single number, or an object with top, left, bottom, right properties.
   * @default 10
   */
  padding: import_prop_types17.default.oneOfType([import_prop_types17.default.number, import_prop_types17.default.shape({
    bottom: import_prop_types17.default.number,
    left: import_prop_types17.default.number,
    right: import_prop_types17.default.number,
    top: import_prop_types17.default.number
  })]),
  /**
   * The position of the legend.
   */
  position: import_prop_types17.default.shape({
    horizontal: import_prop_types17.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types17.default.oneOf(["bottom", "middle", "top"]).isRequired
  }).isRequired,
  series: import_prop_types17.default.object.isRequired,
  seriesToDisplay: import_prop_types17.default.arrayOf(import_prop_types17.default.shape({
    color: import_prop_types17.default.string.isRequired,
    id: import_prop_types17.default.oneOfType([import_prop_types17.default.number, import_prop_types17.default.string]).isRequired,
    label: import_prop_types17.default.string.isRequired
  })).isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var useUtilityClasses6 = (ownerState) => {
  const {
    classes,
    direction
  } = ownerState;
  const slots = {
    root: ["root", direction],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
var defaultProps3 = {
  position: {
    horizontal: "middle",
    vertical: "top"
  },
  direction: "row"
};
function ChartsLegend(inProps) {
  const props = useThemeProps({
    props: _extends({}, defaultProps3, inProps),
    name: "MuiChartsLegend"
  });
  const {
    position,
    direction,
    hidden,
    slots,
    slotProps
  } = props;
  const theme = useTheme();
  const classes = useUtilityClasses6(_extends({}, props, {
    theme
  }));
  const drawingArea = useDrawingArea();
  const series = useSeries();
  const seriesToDisplay = getSeriesToDisplay(series);
  const ChartLegendRender = (slots == null ? void 0 : slots.legend) ?? DefaultChartsLegend;
  const chartLegendRenderProps = useSlotProps({
    elementType: ChartLegendRender,
    externalSlotProps: slotProps == null ? void 0 : slotProps.legend,
    additionalProps: {
      position,
      direction,
      classes,
      drawingArea,
      series,
      hidden,
      seriesToDisplay
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime30.jsx)(ChartLegendRender, _extends({}, chartLegendRenderProps));
}
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types18.default.object,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types18.default.oneOf(["column", "row"]),
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types18.default.bool,
  /**
   * The position of the legend.
   */
  position: import_prop_types18.default.shape({
    horizontal: import_prop_types18.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types18.default.oneOf(["bottom", "middle", "top"]).isRequired
  }),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types18.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types18.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
init_extends();
var React50 = __toESM(require_react());
var import_prop_types19 = __toESM(require_prop_types());
init_composeClasses();
init_generateUtilityClass();
init_generateUtilityClasses();
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);
var useUtilityClasses7 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
var ChartsAxisHighlightPath = styled_default("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState,
  theme
}) => _extends({
  pointerEvents: "none"
}, ownerState.axisHighlight === "band" && {
  fill: theme.palette.mode === "light" ? "gray" : "white",
  fillOpacity: 0.1
}, ownerState.axisHighlight === "line" && {
  strokeDasharray: "5 2",
  stroke: theme.palette.mode === "light" ? "#000000" : "#ffffff"
}));
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const classes = useUtilityClasses7();
  const USED_X_AXIS_ID = xAxisIds[0];
  const USED_Y_AXIS_ID = yAxisIds[0];
  const xScale = xAxis[USED_X_AXIS_ID].scale;
  const yScale = yAxis[USED_Y_AXIS_ID].scale;
  const {
    axis
  } = React50.useContext(InteractionContext);
  const getXPosition = getValueToPositionMapper(xScale);
  const getYPosition = getValueToPositionMapper(yScale);
  const axisX = axis.x;
  const axisY = axis.y;
  const isBandScaleX = xAxisHighlight === "band" && axisX !== null && isBandScale(xScale);
  const isBandScaleY = yAxisHighlight === "band" && axisY !== null && isBandScale(yScale);
  if (true) {
    const isXError = isBandScaleX && xScale(axisX.value) === void 0;
    const isYError = isBandScaleY && yScale(axisY.value) === void 0;
    if (isXError || isYError) {
      console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime31.jsxs)(React50.Fragment, {
    children: [isBandScaleX && xScale(axisX.value) !== void 0 && (0, import_jsx_runtime31.jsx)(
      ChartsAxisHighlightPath,
      {
        d: `M ${xScale(axisX.value) - (xScale.step() - xScale.bandwidth()) / 2} ${yScale.range()[0]} l ${xScale.step()} 0 l 0 ${yScale.range()[1] - yScale.range()[0]} l ${-xScale.step()} 0 Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }
    ), isBandScaleY && yScale(axisY.value) !== void 0 && (0, import_jsx_runtime31.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${// @ts-expect-error, yScale value is checked in the statement above
      yScale(axisY.value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${xScale.range()[1] - xScale.range()[0]} 0 l 0 ${-yScale.step()} Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), xAxisHighlight === "line" && axis.x !== null && (0, import_jsx_runtime31.jsx)(ChartsAxisHighlightPath, {
      d: `M ${getXPosition(axis.x.value)} ${yScale.range()[0]} L ${getXPosition(axis.x.value)} ${yScale.range()[1]}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    }), yAxisHighlight === "line" && axis.y !== null && (0, import_jsx_runtime31.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${getYPosition(axis.y.value)} L ${xScale.range()[1]} ${getYPosition(axis.y.value)}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types19.default.oneOf(["band", "line", "none"]),
  y: import_prop_types19.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsClipPath/ChartsClipPath.js
init_extends();
var React51 = __toESM(require_react());
var import_prop_types20 = __toESM(require_prop_types());
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const offset = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime32.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime32.jsx)("rect", {
      x: left - offset.left,
      y: top - offset.top,
      width: width + offset.left + offset.right,
      height: height + offset.top + offset.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  id: import_prop_types20.default.string.isRequired,
  offset: import_prop_types20.default.shape({
    bottom: import_prop_types20.default.number,
    left: import_prop_types20.default.number,
    right: import_prop_types20.default.number,
    top: import_prop_types20.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
init_extends();
init_objectWithoutPropertiesLoose();
var React52 = __toESM(require_react());
var import_prop_types21 = __toESM(require_prop_types());
init_composeClasses();

// node_modules/@mui/x-charts/esm/ChartsGrid/chartsGridClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var _excluded14 = ["vertical", "horizontal"];
var GridRoot = styled_default("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default("line", {
  name: "MuiChartsGrid",
  slot: "Line",
  overridesResolver: (props, styles) => styles.line
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));
var useUtilityClasses8 = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(props) {
  const themeProps = useThemeProps({
    props,
    name: "MuiChartsGrid"
  });
  const {
    vertical,
    horizontal
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded14);
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const classes = useUtilityClasses8(themeProps);
  const horizontalAxisId = yAxisIds[0];
  const verticalAxisId = xAxisIds[0];
  const {
    scale: xScale,
    tickNumber: xTickNumber,
    tickInterval: xTickInterval
  } = xAxis[verticalAxisId];
  const {
    scale: yScale,
    tickNumber: yTickNumber,
    tickInterval: yTickInterval
  } = yAxis[horizontalAxisId];
  const xTicks = useTicks({
    scale: xScale,
    tickNumber: xTickNumber,
    tickInterval: xTickInterval
  });
  const yTicks = useTicks({
    scale: yScale,
    tickNumber: yTickNumber,
    tickInterval: yTickInterval
  });
  return (0, import_jsx_runtime33.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && xTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime33.jsx)(GridLine, {
      y1: yScale.range()[0],
      y2: yScale.range()[1],
      x1: offset,
      x2: offset,
      className: classes.verticalLine
    }, `vertical-${formattedValue}`)), horizontal && yTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime33.jsx)(GridLine, {
      y1: offset,
      y2: offset,
      x1: xScale.range()[0],
      x2: xScale.range()[1],
      className: classes.horizontalLine
    }, `horizontal-${formattedValue}`))]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types21.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types21.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types21.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsOnAxisClickHandler/ChartsOnAxisClickHandler.js
var React53 = __toESM(require_react());
var import_prop_types22 = __toESM(require_prop_types());
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
function ChartsOnAxisClickHandler(props) {
  const {
    onAxisClick
  } = props;
  const svgRef = useSvgRef();
  const series = useSeries();
  const {
    axis
  } = React53.useContext(InteractionContext);
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  React53.useEffect(() => {
    const element = svgRef.current;
    if (element === null || !onAxisClick) {
      return () => {
      };
    }
    const handleMouseClick = (event) => {
      var _a;
      event.preventDefault();
      const isXaxis = (axis.x && axis.x.index) !== void 0;
      const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
      const dataIndex = isXaxis ? axis.x && axis.x.index : axis.y && axis.y.index;
      if (dataIndex == null) {
        return;
      }
      const seriesValues = {};
      Object.keys(series).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
        var _a2;
        (_a2 = series[seriesType]) == null ? void 0 : _a2.seriesOrder.forEach((seriesId) => {
          const seriesItem = series[seriesType].series[seriesId];
          const axisKey = isXaxis ? seriesItem.xAxisKey : seriesItem.yAxisKey;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            seriesValues[seriesId] = seriesItem.data[dataIndex];
          }
        });
      });
      const axisValue = (_a = (isXaxis ? xAxis : yAxis)[USED_AXIS_ID].data) == null ? void 0 : _a[dataIndex];
      onAxisClick(event, {
        dataIndex,
        axisValue,
        seriesValues
      });
    };
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("click", handleMouseClick);
    };
  }, [axis.x, axis.y, onAxisClick, series, svgRef, xAxis, xAxisIds, yAxis, yAxisIds]);
  return (0, import_jsx_runtime34.jsx)(React53.Fragment, {});
}
true ? ChartsOnAxisClickHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types22.default.func
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
init_extends();
var React56 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsLoadingOverlay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React54 = __toESM(require_react());
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var _excluded15 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime35.jsx)(StyledText, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "Loading data"
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsNoDataOverlay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React55 = __toESM(require_react());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var _excluded16 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime36.jsx)(StyledText2, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "No data to display"
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime37.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime37.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js
init_extends();
init_useId();
var useBarChartProps = (props) => {
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    tooltip,
    onAxisClick,
    axisHighlight,
    legend,
    grid,
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    children,
    slots,
    slotProps,
    skipAnimation,
    loading,
    layout,
    onItemClick,
    highlightedItem,
    onHighlightChange,
    borderRadius,
    barLabel
  } = props;
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const hasHorizontalSeries = layout === "horizontal" || layout === void 0 && series.some((item) => item.layout === "horizontal");
  const defaultAxisConfig = {
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
    }, (_, index) => index)
  };
  const chartContainerProps = {
    series: series.map((s) => _extends({
      type: "bar"
    }, s, {
      layout: hasHorizontalSeries ? "horizontal" : "vertical"
    })),
    width,
    height,
    margin,
    colors,
    dataset,
    xAxis: xAxis ?? (hasHorizontalSeries ? void 0 : [_extends({
      id: DEFAULT_X_AXIS_KEY
    }, defaultAxisConfig)]),
    yAxis: yAxis ?? (hasHorizontalSeries ? [_extends({
      id: DEFAULT_Y_AXIS_KEY
    }, defaultAxisConfig)] : void 0),
    sx,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none" && !onAxisClick
  };
  const barPlotProps = {
    onItemClick,
    slots,
    slotProps,
    skipAnimation,
    borderRadius,
    barLabel
  };
  const axisClickHandlerProps = {
    onAxisClick
  };
  const gridProps = {
    vertical: grid == null ? void 0 : grid.vertical,
    horizontal: grid == null ? void 0 : grid.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({}, hasHorizontalSeries ? {
    y: "band"
  } : {
    x: "band"
  }, axisHighlight);
  const legendProps = _extends({}, legend, {
    slots,
    slotProps
  });
  const tooltipProps = _extends({}, tooltip, {
    slots,
    slotProps
  });
  return {
    chartContainerProps,
    barPlotProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    tooltipProps,
    children
  };
};

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var BarChart = React57.forwardRef(function BarChart2(props, ref) {
  const {
    chartContainerProps,
    barPlotProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    tooltipProps,
    children
  } = useBarChartProps(props);
  return (0, import_jsx_runtime38.jsxs)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: [props.onAxisClick && (0, import_jsx_runtime38.jsx)(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), props.grid && (0, import_jsx_runtime38.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime38.jsxs)("g", _extends({}, clipPathGroupProps, {
      children: [(0, import_jsx_runtime38.jsx)(BarPlot, _extends({}, barPlotProps)), (0, import_jsx_runtime38.jsx)(ChartsOverlay, _extends({}, overlayProps))]
    })), (0, import_jsx_runtime38.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime38.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime38.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps)), !props.loading && (0, import_jsx_runtime38.jsx)(ChartsTooltip, _extends({}, tooltipProps)), (0, import_jsx_runtime38.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
  }));
});
true ? BarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * Default is set to 'band' in the bar direction.
   * Depends on `layout` prop.
   * @see See {@link https://mui.com/x/react-charts/tooltip/#highlights highlight docs} for more details.
   */
  axisHighlight: import_prop_types23.default.shape({
    x: import_prop_types23.default.oneOf(["band", "line", "none"]),
    y: import_prop_types23.default.oneOf(["band", "line", "none"])
  }),
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["value"]), import_prop_types23.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types23.default.number,
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types23.default.oneOfType([import_prop_types23.default.object, import_prop_types23.default.string]),
  children: import_prop_types23.default.node,
  className: import_prop_types23.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string), import_prop_types23.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types23.default.arrayOf(import_prop_types23.default.object),
  desc: import_prop_types23.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types23.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types23.default.shape({
    horizontal: import_prop_types23.default.bool,
    vertical: import_prop_types23.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types23.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types23.default.shape({
    dataIndex: import_prop_types23.default.number,
    seriesId: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string])
  }),
  /**
   * The direction of the bar elements.
   * @default 'vertical'
   */
  layout: import_prop_types23.default.oneOf(["horizontal", "vertical"]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types23.default.oneOfType([import_prop_types23.default.object, import_prop_types23.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types23.default.shape({
    classes: import_prop_types23.default.object,
    direction: import_prop_types23.default.oneOf(["column", "row"]),
    hidden: import_prop_types23.default.bool,
    position: import_prop_types23.default.shape({
      horizontal: import_prop_types23.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types23.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types23.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types23.default.shape({
    bottom: import_prop_types23.default.number,
    left: import_prop_types23.default.number,
    right: import_prop_types23.default.number,
    top: import_prop_types23.default.number
  }),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types23.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types23.default.func,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types23.default.func,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types23.default.oneOfType([import_prop_types23.default.object, import_prop_types23.default.string]),
  /**
   * The series to display in the bar chart.
   * An array of [[BarSeriesType]] objects.
   */
  series: import_prop_types23.default.arrayOf(import_prop_types23.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types23.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types23.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types23.default.object,
  sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
  title: import_prop_types23.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   */
  tooltip: import_prop_types23.default.shape({
    axisContent: import_prop_types23.default.elementType,
    classes: import_prop_types23.default.object,
    itemContent: import_prop_types23.default.elementType,
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object,
    trigger: import_prop_types23.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types23.default.oneOfType([import_prop_types23.default.object, import_prop_types23.default.string]),
  viewBox: import_prop_types23.default.shape({
    height: import_prop_types23.default.number,
    width: import_prop_types23.default.number,
    x: import_prop_types23.default.number,
    y: import_prop_types23.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types23.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types23.default.arrayOf(import_prop_types23.default.shape({
    axisId: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    classes: import_prop_types23.default.object,
    colorMap: import_prop_types23.default.oneOfType([import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      type: import_prop_types23.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types23.default.string,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number, import_prop_types23.default.string]).isRequired)
    }), import_prop_types23.default.shape({
      color: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string.isRequired), import_prop_types23.default.func]).isRequired,
      max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      type: import_prop_types23.default.oneOf(["continuous"]).isRequired
    }), import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      thresholds: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]).isRequired).isRequired,
      type: import_prop_types23.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types23.default.array,
    dataKey: import_prop_types23.default.string,
    disableLine: import_prop_types23.default.bool,
    disableTicks: import_prop_types23.default.bool,
    fill: import_prop_types23.default.string,
    hideTooltip: import_prop_types23.default.bool,
    id: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    label: import_prop_types23.default.string,
    labelFontSize: import_prop_types23.default.number,
    labelStyle: import_prop_types23.default.object,
    max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    position: import_prop_types23.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types23.default.bool,
    scaleType: import_prop_types23.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object,
    stroke: import_prop_types23.default.string,
    tickFontSize: import_prop_types23.default.number,
    tickInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.array, import_prop_types23.default.func]),
    tickLabelInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.func]),
    tickLabelPlacement: import_prop_types23.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types23.default.object,
    tickMaxStep: import_prop_types23.default.number,
    tickMinStep: import_prop_types23.default.number,
    tickNumber: import_prop_types23.default.number,
    tickPlacement: import_prop_types23.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types23.default.number,
    valueFormatter: import_prop_types23.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types23.default.arrayOf(import_prop_types23.default.shape({
    axisId: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    classes: import_prop_types23.default.object,
    colorMap: import_prop_types23.default.oneOfType([import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      type: import_prop_types23.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types23.default.string,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number, import_prop_types23.default.string]).isRequired)
    }), import_prop_types23.default.shape({
      color: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string.isRequired), import_prop_types23.default.func]).isRequired,
      max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      type: import_prop_types23.default.oneOf(["continuous"]).isRequired
    }), import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      thresholds: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]).isRequired).isRequired,
      type: import_prop_types23.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types23.default.array,
    dataKey: import_prop_types23.default.string,
    disableLine: import_prop_types23.default.bool,
    disableTicks: import_prop_types23.default.bool,
    fill: import_prop_types23.default.string,
    hideTooltip: import_prop_types23.default.bool,
    id: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    label: import_prop_types23.default.string,
    labelFontSize: import_prop_types23.default.number,
    labelStyle: import_prop_types23.default.object,
    max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    position: import_prop_types23.default.oneOf(["left", "right"]),
    reverse: import_prop_types23.default.bool,
    scaleType: import_prop_types23.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object,
    stroke: import_prop_types23.default.string,
    tickFontSize: import_prop_types23.default.number,
    tickInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.array, import_prop_types23.default.func]),
    tickLabelInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.func]),
    tickLabelPlacement: import_prop_types23.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types23.default.object,
    tickMaxStep: import_prop_types23.default.number,
    tickMinStep: import_prop_types23.default.number,
    tickNumber: import_prop_types23.default.number,
    tickPlacement: import_prop_types23.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types23.default.number,
    valueFormatter: import_prop_types23.default.func
  }))
} : void 0;

export {
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DEFAULT_MARGINS,
  HighlightedContext,
  blueberryTwilightPaletteLight,
  blueberryTwilightPaletteDark,
  blueberryTwilightPalette,
  mangoFusionPaletteLight,
  mangoFusionPaletteDark,
  mangoFusionPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  cheerfulFiestaPalette,
  useSeries,
  usePieSeries,
  useLineSeries,
  useBarSeries,
  useScatterSeries,
  HighlightedProvider,
  useHighlighted,
  useItemHighlighted,
  ZAxisContext,
  ZAxisContextProvider,
  DrawingContext,
  DrawingProvider,
  useDrawingArea,
  useChartId,
  useCartesianContext,
  useXAxis,
  useYAxis,
  getValueToPositionMapper,
  useXScale,
  useYScale,
  useXColorScale,
  useYColorScale,
  useZColorScale,
  useSvgRef,
  ChartsClipPath,
  ChartsText,
  getAxisUtilityClass,
  axisClasses,
  ChartsXAxis,
  ChartsYAxis,
  ChartsAxis,
  getChartsGridUtilityClass,
  chartsGridClasses,
  ChartsGrid,
  InteractionContext,
  getChartsTooltipUtilityClass,
  chartsTooltipClasses,
  ChartsTooltipPaper,
  ChartsTooltipTable,
  ChartsTooltipRow,
  ChartsTooltipCell,
  ChartsTooltipMark,
  getLabel,
  DefaultChartsItemTooltipContent,
  ChartsItemTooltipContent,
  DefaultChartsAxisTooltipContent,
  ChartsAxisTooltipContent,
  ChartsTooltip,
  getSeriesToDisplay,
  getLegendUtilityClass,
  legendClasses,
  ChartsLegendRoot,
  DefaultChartsLegend,
  ChartsLegend,
  getAxisHighlightUtilityClass,
  chartsAxisHighlightClasses,
  ChartsAxisHighlightPath,
  ChartsAxisHighlight,
  getSVGPoint,
  ChartsOnAxisClickHandler,
  useInteractionItemProps,
  getBarElementUtilityClass,
  barElementClasses,
  BarElementPath,
  BarElement,
  getBarLabelUtilityClass,
  barLabelClasses,
  BarLabel,
  BarPlot,
  ChartsSurface,
  useChartGradient,
  getColor2 as getColor,
  getColor3 as getColor2,
  ChartContainer,
  useChartContainerDimensions,
  ResponsiveChartContainer,
  ChartsOverlay,
  BarChart
};
//# sourceMappingURL=chunk-6ANBJ6VF.js.map
